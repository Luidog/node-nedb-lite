<style>
.docApiDiv {
    font-family: Arial, Helvetica, sans-serif;
}
.docApiDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.docApiDiv a[href]:hover {
    text-decoration: underline;
}
.docApiSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.docApiCodeCommentSpan {
    background-color: #bbf;
    color: #000;
    display: block;
}
.docApiCodeKeywordSpan {
    color: #f00;
    font-weight: bold;
}
.docApiCodePre {
    background-color: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.docApiSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<div class="docApiDiv">
<h1>api documentation
    <a
        
        href="https://github.com/kaizhu256/node-nedb-lite"
        
    >(nedb-lite v2016.9.1)</a>
</h1>
<div class="docApiSectionDiv"><a href="#"><h1>table of contents</h1></a><ul>

    <li><a href="#module.Nedb">module Nedb</a><ol>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.Nedb">
            function <span class="docApiSignatureSpan"/span>Nedb
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.Executor">
            function <span class="docApiSignatureSpan">Nedb.</span>Executor
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.Index">
            function <span class="docApiSignatureSpan">Nedb.</span>Index
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.Persistence">
            function <span class="docApiSignatureSpan">Nedb.</span>Persistence
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.assert">
            function <span class="docApiSignatureSpan">Nedb.</span>assert
            <span class="docApiSignatureSpan">(passed, message)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.asyncEachSeries">
            function <span class="docApiSignatureSpan">Nedb.</span>asyncEachSeries
            <span class="docApiSignatureSpan">(arr, iterator, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.asyncQueue">
            function <span class="docApiSignatureSpan">Nedb.</span>asyncQueue
            <span class="docApiSignatureSpan">(worker)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.avltree">
            function <span class="docApiSignatureSpan">Nedb.</span>avltree
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.bst">
            function <span class="docApiSignatureSpan">Nedb.</span>bst
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.crudOptionsSetDefault">
            function <span class="docApiSignatureSpan">Nedb.</span>crudOptionsSetDefault
            <span class="docApiSignatureSpan">(options, defaults)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.cursor">
            function <span class="docApiSignatureSpan">Nedb.</span>cursor
            <span class="docApiSignatureSpan">(db, query, execFn)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.dbExport">
            function <span class="docApiSignatureSpan">Nedb.</span>dbExport
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.dbImport">
            function <span class="docApiSignatureSpan">Nedb.</span>dbImport
            <span class="docApiSignatureSpan">(tableList, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.dbReset">
            function <span class="docApiSignatureSpan">Nedb.</span>dbReset
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.dbTableCreate">
            function <span class="docApiSignatureSpan">Nedb.</span>dbTableCreate
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.dbTableDrop">
            function <span class="docApiSignatureSpan">Nedb.</span>dbTableDrop
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.executor">
            function <span class="docApiSignatureSpan">Nedb.</span>executor
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.fsDir">
            function <span class="docApiSignatureSpan">Nedb.</span>fsDir
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.indexes">
            function <span class="docApiSignatureSpan">Nedb.</span>indexes
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.inherits">
            function <span class="docApiSignatureSpan">Nedb.</span>inherits
            <span class="docApiSignatureSpan">(ctor, superCtor)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.isDate">
            function <span class="docApiSignatureSpan">Nedb.</span>isDate
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.isRegExp">
            function <span class="docApiSignatureSpan">Nedb.</span>isRegExp
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.jsonStringifyOrdered">
            function <span class="docApiSignatureSpan">Nedb.</span>jsonStringifyOrdered
            <span class="docApiSignatureSpan">(element, replacer, space)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.listUnique">
            function <span class="docApiSignatureSpan">Nedb.</span>listUnique
            <span class="docApiSignatureSpan">(list)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.local">
            function <span class="docApiSignatureSpan">Nedb.</span>local
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.middleware">
            function <span class="docApiSignatureSpan">Nedb.</span>middleware
            <span class="docApiSignatureSpan">(request, response, nextMiddleware)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.middlewareError">
            function <span class="docApiSignatureSpan">Nedb.</span>middlewareError
            <span class="docApiSignatureSpan">(error, request, response)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.nop">
            function <span class="docApiSignatureSpan">Nedb.</span>nop
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence">
            function <span class="docApiSignatureSpan">Nedb.</span>persistence
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.sortCompare">
            function <span class="docApiSignatureSpan">Nedb.</span>sortCompare
            <span class="docApiSignatureSpan">(aa, bb)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeAction">
            function <span class="docApiSignatureSpan">Nedb.</span>storeAction
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeClear">
            function <span class="docApiSignatureSpan">Nedb.</span>storeClear
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeGetItem">
            function <span class="docApiSignatureSpan">Nedb.</span>storeGetItem
            <span class="docApiSignatureSpan">(key, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeInit">
            function <span class="docApiSignatureSpan">Nedb.</span>storeInit
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeKeys">
            function <span class="docApiSignatureSpan">Nedb.</span>storeKeys
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeLength">
            function <span class="docApiSignatureSpan">Nedb.</span>storeLength
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeRemoveItem">
            function <span class="docApiSignatureSpan">Nedb.</span>storeRemoveItem
            <span class="docApiSignatureSpan">(key, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.storeSetItem">
            function <span class="docApiSignatureSpan">Nedb.</span>storeSetItem
            <span class="docApiSignatureSpan">(key, value, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_assertXxx_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_assertXxx_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_build_app">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_build_app
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_build_doc">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_build_doc
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbExport_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbExport_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbImport_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbImport_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbTableCreate_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableCreate_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbTableCreate_error">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableCreate_error
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbTableDrop_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableDrop_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbTableFindOneById_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableFindOneById_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_dbTableRemoveOneById_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableRemoveOneById_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_jsonStringifyOrdered_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_jsonStringifyOrdered_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.testCase_webpage_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_webpage_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>child_process</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>customUtils</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>dbTableDict</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>fs</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>global</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>http</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>model</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>onReadyAfter</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>os</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>path</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>storePromiseList</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>url</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">object <span class="docApiSignatureSpan">Nedb.</span>utility2</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">string <span class="docApiSignatureSpan">Nedb.</span>NODE_ENV</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">string <span class="docApiSignatureSpan">Nedb.</span>fsDirInitialized</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">string <span class="docApiSignatureSpan">Nedb.</span>modeJs</span>
        
        </li>
        
        <li>
            
            <span class="docApiSignatureSpan">string <span class="docApiSignatureSpan">Nedb.</span>templateIndexHtml</span>
        
        </li>
        
    </ol></li>

    <li><a href="#module.Nedb.customUtils">module Nedb.customUtils</a><ol>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.customUtils.uid">
            function <span class="docApiSignatureSpan">Nedb.customUtils.</span>uid
            <span class="docApiSignatureSpan">(len)</span>
            </a>
            
        </li>
        
    </ol></li>

    <li><a href="#module.Nedb.model">module Nedb.model</a><ol>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.areThingsEqual">
            function <span class="docApiSignatureSpan">Nedb.model.</span>areThingsEqual
            <span class="docApiSignatureSpan">(a, b)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.checkObject">
            function <span class="docApiSignatureSpan">Nedb.model.</span>checkObject
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.deepCopy">
            function <span class="docApiSignatureSpan">Nedb.model.</span>deepCopy
            <span class="docApiSignatureSpan">(obj, strictKeys)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.deserialize">
            function <span class="docApiSignatureSpan">Nedb.model.</span>deserialize
            <span class="docApiSignatureSpan">(rawData)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.getDotValue">
            function <span class="docApiSignatureSpan">Nedb.model.</span>getDotValue
            <span class="docApiSignatureSpan">(obj, field)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.isPrimitiveType">
            function <span class="docApiSignatureSpan">Nedb.model.</span>isPrimitiveType
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.match">
            function <span class="docApiSignatureSpan">Nedb.model.</span>match
            <span class="docApiSignatureSpan">(obj, query)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.modify">
            function <span class="docApiSignatureSpan">Nedb.model.</span>modify
            <span class="docApiSignatureSpan">(obj, updateQuery)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.model.serialize">
            function <span class="docApiSignatureSpan">Nedb.model.</span>serialize
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
            
        </li>
        
    </ol></li>

    <li><a href="#module.Nedb.persistence">module Nedb.persistence</a><ol>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence.persistence">
            function <span class="docApiSignatureSpan">Nedb.</span>persistence
            <span class="docApiSignatureSpan">(options)</span>
            </a>
            
        </li>
        
    </ol></li>

    <li><a href="#module.Nedb.persistence.prototype">module Nedb.persistence.prototype</a><ol>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence.prototype.compactDatafile">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>compactDatafile
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence.prototype.loadDatabase">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>loadDatabase
            <span class="docApiSignatureSpan">(cb)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence.prototype.persistCachedDatabase">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>persistCachedDatabase
            <span class="docApiSignatureSpan">(cb)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence.prototype.persistNewState">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>persistNewState
            <span class="docApiSignatureSpan">(newDocs, cb)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.persistence.prototype.treatRawData">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>treatRawData
            <span class="docApiSignatureSpan">(rawData)</span>
            </a>
            
        </li>
        
    </ol></li>

    <li><a href="#module.Nedb.prototype">module Nedb.prototype</a><ol>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.addToIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>addToIndexes
            <span class="docApiSignatureSpan">(doc)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.count">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>count
            <span class="docApiSignatureSpan">(query, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.createNewId">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>createNewId
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.ensureIndex">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>ensureIndex
            <span class="docApiSignatureSpan">(options, cb)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.export">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>export
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.find">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>find
            <span class="docApiSignatureSpan">(query, projection, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.findOne">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>findOne
            <span class="docApiSignatureSpan">(query, projection, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.getAllData">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>getAllData
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.getCandidates">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>getCandidates
            <span class="docApiSignatureSpan">(query, dontExpireStaleDocs, callback)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.insert">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>insert
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.load">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>load
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.loadDatabase">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>loadDatabase
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.prepareDocumentForInsertion">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>prepareDocumentForInsertion
            <span class="docApiSignatureSpan">(newDoc)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.remove">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>remove
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.removeFromIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>removeFromIndexes
            <span class="docApiSignatureSpan">(doc)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.removeIndex">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>removeIndex
            <span class="docApiSignatureSpan">(fieldName, cb)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.resetIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>resetIndexes
            <span class="docApiSignatureSpan">(newData)</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.update">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>update
            <span class="docApiSignatureSpan">()</span>
            </a>
            
        </li>
        
        <li>
            
            <a class="docApiElementLiA" href="#element.Nedb.prototype.updateIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>updateIndexes
            <span class="docApiSignatureSpan">(oldDoc, newDoc)</span>
            </a>
            
        </li>
        
    </ol></li>

</ul></div>
    
    <div class="docApiSectionDiv">
    <h1><a href="#module.Nedb" id="module.Nedb">module Nedb</a></h1>
        
        
        <h2>
            <a href="#element.Nedb.Nedb" id="element.Nedb.Nedb">
            function <span class="docApiSignatureSpan"/span>Nedb
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">Nedb = function (options, onError) {
<span class="docApiCodeCommentSpan">/**
 * Create a new collection
 * @param {String} options.name
 * @param {Function} onError Optional,
 * if autoload is used this will be called after the load database
 * with the error object as parameter. If you don&#x27;t pass it the error will be thrown
 */
</span>    // validate name
    if (!(options &amp;&amp; options.name &amp;&amp; typeof options.name === &#x27;string&#x27;)) {
        throw new Error(&#x27;Nedb - missing name param, e.g. new Nedb({ name: &quot;table1&quot; })&#x27;);
    }
    this.name = options.name;
    local.dbTableDrop(this, local.nop);
    local.dbTableDict[this.name] = this;
    // Persistence handling
    this.persistence = new local.Persistence({ db: this });
    // This new executor is ready if we don&#x27;t use persistence
    // If we do, it will only be ready once loadDatabase is called
    this.executor = new local.Executor();
    // Indexed by field name, dot notation can be used
    // _id is always indexed and since _ids are generated randomly the underlying
    // binary is always well-balanced
    this.indexes = {
        _id: new local.Index({ fieldName: &#x27;_id&#x27;, unique: true }),
        createdAt: new local.Index({ fieldName: &#x27;createdAt&#x27; }),
        updatedAt: new local.Index({ fieldName: &#x27;updatedAt&#x27; })
    };
    this.ttlIndexes = {};
    this.load(options, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
*
* this package will run a standalone, browser-compatible version of the nedb v1.8.0 database
* with zero npm-dependencies
*
* browser example:
*     &lt;script src=&quot;assets.nedb-lite.js&quot;&gt;&lt;/script&gt;
*     &lt;script&gt;
*     var table = new window.<span class="docApiCodeKeywordSpan">Nedb</span>({ name: &#x27;table1&#x27; });
*     table.insert({ field1: &#x27;hello&#x27;, field2: &#x27;world&#x27;}, console.log.bind(console));
*     &lt;/script&gt;
*
* node example:
*     var Nedb = require(&#x27;./assets.nedb-lite.js&#x27;);
*     var table = new Nedb({ name: &#x27;table1&#x27; });
*     table.insert({ field1: &#x27;hello&#x27;, field2: &#x27;world&#x27;}, console.log.bind(console));
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.Executor" id="element.Nedb.Executor">
            function <span class="docApiSignatureSpan">Nedb.</span>Executor
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Executor() {
    this.buffer = [];
    this.ready = false;

    // This queue will execute all commands, one-by-one in order
    this.queue = local.asyncQueue(function (task, cb) {
        var newArguments = [];

        // task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
        for (var i = 0; i &lt; task.arguments.length; i += 1) {
            newArguments.push(task.arguments[i]);
        }
        var lastArg = task.arguments[task.arguments.length - 1];

        // Always tell the queue task is complete. Execute callback if any was given.
        if (typeof lastArg === &#x27;function&#x27;) {
            // Callback was supplied
            newArguments[newArguments.length - 1] = function () {
                if (typeof setImmediate === &#x27;function&#x27;) {
                    setImmediate(cb);
                } else {
                    setTimeout(cb);
                }
                lastArg.apply(null, arguments);
            };
        } else if (!lastArg &amp;&amp; task.arguments.length !== 0) {
            // false/undefined/null supplied as callbback
            newArguments[newArguments.length - 1] = function () {
                cb();
            };
        } else {
            // Nothing supplied as callback
            newArguments.push(function () {
                cb();
            });
        }


        task.fn.apply(task.this, newArguments);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
this.name = options.name;
local.dbTableDrop(this, local.nop);
local.dbTableDict[this.name] = this;
// Persistence handling
this.persistence = new local.Persistence({ db: this });
// This new executor is ready if we don&#x27;t use persistence
// If we do, it will only be ready once loadDatabase is called
this.executor = new local.<span class="docApiCodeKeywordSpan">Executor</span>();
// Indexed by field name, dot notation can be used
// _id is always indexed and since _ids are generated randomly the underlying
// binary is always well-balanced
this.indexes = {
    _id: new local.Index({ fieldName: &#x27;_id&#x27;, unique: true }),
    createdAt: new local.Index({ fieldName: &#x27;createdAt&#x27; }),
    updatedAt: new local.Index({ fieldName: &#x27;updatedAt&#x27; })
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.Index" id="element.Nedb.Index">
            function <span class="docApiSignatureSpan">Nedb.</span>Index
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Index(options) {
    this.fieldName = options.fieldName;
    this.unique = options.unique || false;
    this.sparse = options.sparse || false;

    this.treeOptions = { unique: this.unique };

    this.reset(); // No data in the beginning
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    // This new executor is ready if we don&#x27;t use persistence
    // If we do, it will only be ready once loadDatabase is called
    this.executor = new local.Executor();
    // Indexed by field name, dot notation can be used
    // _id is always indexed and since _ids are generated randomly the underlying
    // binary is always well-balanced
    this.indexes = {
        _id: new local.<span class="docApiCodeKeywordSpan">Index</span>({ fieldName: &#x27;_id&#x27;, unique: true }),
        createdAt: new local.Index({ fieldName: &#x27;createdAt&#x27; }),
        updatedAt: new local.Index({ fieldName: &#x27;updatedAt&#x27; })
    };
    this.ttlIndexes = {};
    this.load(options, onError);
};
local.Nedb = local.local = local;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.Persistence" id="element.Nedb.Persistence">
            function <span class="docApiSignatureSpan">Nedb.</span>Persistence
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Persistence(options) {
    var i, j, randomString;

    this.db = options.db;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
if (!(options &amp;&amp; options.name &amp;&amp; typeof options.name === &#x27;string&#x27;)) {
    throw new Error(&#x27;Nedb - missing name param, e.g. new Nedb({ name: &quot;table1&quot; })&#x27;);
}
this.name = options.name;
local.dbTableDrop(this, local.nop);
local.dbTableDict[this.name] = this;
// Persistence handling
this.persistence = new local.<span class="docApiCodeKeywordSpan">Persistence</span>({ db: this });
// This new executor is ready if we don&#x27;t use persistence
// If we do, it will only be ready once loadDatabase is called
this.executor = new local.Executor();
// Indexed by field name, dot notation can be used
// _id is always indexed and since _ids are generated randomly the underlying
// binary is always well-balanced
this.indexes = {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.assert" id="element.Nedb.assert">
            function <span class="docApiSignatureSpan">Nedb.</span>assert
            <span class="docApiSignatureSpan">(passed, message)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">assert = function (passed, message) {
<span class="docApiCodeCommentSpan">/*
 * this function will throw the error message if passed is falsey
 */
</span>    var error;
    if (passed) {
        return;
    }
    error = message &amp;&amp; message.message
        // if message is an error-object, then leave it as is
        ? message
        : new Error(typeof message === &#x27;string&#x27;
            // if message is a string, then leave it as is
            ? message
            // else JSON.stringify message
            : JSON.stringify(message));
    throw error;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...

local.testCase_assertXxx_default = function (options, onError) {
/*
 * this function will test assertXxx&#x27;s default handling-behavior
 */
    options = {};
    // test assertion passed
    local.utility2.<span class="docApiCodeKeywordSpan">assert</span>(true, true);
    // test assertion failed with undefined message
    local.utility2.tryCatchOnError(function () {
        local.utility2.assert(false);
    }, function (error) {
        // validate error occurred
        local.utility2.assert(error, error);
        // validate error-message
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.asyncEachSeries" id="element.Nedb.asyncEachSeries">
            function <span class="docApiSignatureSpan">Nedb.</span>asyncEachSeries
            <span class="docApiSignatureSpan">(arr, iterator, callback)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">asyncEachSeries = function (arr, iterator, callback) {
    var completed, iterate;
    if (!arr.length) {
        return callback();
    }
    completed = 0;
    iterate = function () {
        iterator(arr[completed], function (error) {
            if (error) {
                callback(error);
                callback = local.nop;
            } else {
                completed += 1;
                if (completed &gt;= arr.length) {
                    callback();
                } else {
                    iterate();
                }
            }
        });
    };
    iterate();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    if (valid) {
        validDocs.push(doc);
    } else {
        expiredDocsIds.push(doc._id);
    }
});

local.<span class="docApiCodeKeywordSpan">asyncEachSeries</span>(expiredDocsIds, function (_id, cb) {
    self._remove({
        _id: _id
    }, {}, function (error) {
        if (error) {
            return callback(error);
        }
        return cb();
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.asyncQueue" id="element.Nedb.asyncQueue">
            function <span class="docApiSignatureSpan">Nedb.</span>asyncQueue
            <span class="docApiSignatureSpan">(worker)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">asyncQueue = function (worker) {
    var self;
    function only_once(fn) {
        var called = false;
        return function () {
            if (called) {
                throw new Error(&quot;Callback was already called.&quot;);
            }
            called = true;
            fn.apply(null, arguments);
        };
    }
    self = {
        tasks: [],
        push: function (data, callback) {
            if (data.constructor !== Array) {
                data = [data];
            }
            data.forEach(function (task) {
                var item = {
                    data: task,
                    callback: typeof callback === &#x27;function&#x27; ? callback : null
                };
                self.tasks.push(item);
            });
            setTimeout(self.process);
        },
        process: function () {
            var task;
            if (!self.isRunningTask &amp;&amp; self.tasks.length) {
                task = self.tasks.shift();
                self.isRunningTask = true;
                worker(task.data, only_once(function () {
                    self.isRunningTask = null;
                    if (task.callback) {
                        task.callback.apply(task, arguments);
                    }
                    self.process();
                }));
            }
        }
    };
    return self;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
             */

            function Executor() {
                this.buffer = [];
                this.ready = false;

                // This queue will execute all commands, one-by-one in order
                this.queue = local.<span class="docApiCodeKeywordSpan">asyncQueue</span>(function (task, cb) {
var newArguments = [];

// task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
for (var i = 0; i &lt; task.arguments.length; i += 1) {
    newArguments.push(task.arguments[i]);
}
var lastArg = task.arguments[task.arguments.length - 1];
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.avltree" id="element.Nedb.avltree">
            function <span class="docApiSignatureSpan">Nedb.</span>avltree
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function AVLTree(options) {
    this.tree = new _AVLTree(options);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.bst" id="element.Nedb.bst">
            function <span class="docApiSignatureSpan">Nedb.</span>bst
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function BinarySearchTree(options) {
    options = options || {};

    this.left = null;
    this.right = null;
    this.parent = options.parent !== undefined ? options.parent : null;
    if (options.hasOwnProperty(&#x27;key&#x27;)) {
        this.key = options.key;
    }
    this.data = options.hasOwnProperty(&#x27;value&#x27;) ? [options.value] : [];
    this.unique = options.unique || false;

}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.crudOptionsSetDefault" id="element.Nedb.crudOptionsSetDefault">
            function <span class="docApiSignatureSpan">Nedb.</span>crudOptionsSetDefault
            <span class="docApiSignatureSpan">(options, defaults)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">crudOptionsSetDefault = function (options, defaults) {
<span class="docApiCodeCommentSpan">/*
 * this function will set default-values for options
 */
</span>    options = local.utility2.objectSetDefault(options, defaults);
    options.table = local.dbTableDict.TestCrud;
    return options;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        /*
* this function will test dbTableFindOneById&#x27;s default handling-behavior
*/
   options = {};
   local.utility2.onNext(options, function (error, data) {
       switch (options.modeNext) {
       case 1:
           options = local.<span class="docApiCodeKeywordSpan">crudOptionsSetDefault</span>(options, {
               id: &#x27;00_test_dbTableFindOneById&#x27;
           });
           options.table.findOne({ id: options.id }, options.onNext);
           break;
       case 2:
           // validate data
           local.utility2.assertJsonEqual(data.id, options.id);
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.cursor" id="element.Nedb.cursor">
            function <span class="docApiSignatureSpan">Nedb.</span>cursor
            <span class="docApiSignatureSpan">(db, query, execFn)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Cursor(db, query, execFn) {
    this.db = db;
    this.query = query || {};
    if (execFn) {
        this.execFn = execFn;
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.dbExport" id="element.Nedb.dbExport">
            function <span class="docApiSignatureSpan">Nedb.</span>dbExport
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">dbExport = function () {
<span class="docApiCodeCommentSpan">/*
 * this function will export the database as a serialized tableList
 */
</span>    var data;
    data = &#x27;&#x27;;
    Object.keys(local.dbTableDict).map(function (key) {
        data += local.dbTableDict[key].export() + &#x27;\n\n&#x27;;
    });
    return data.slice(0, -2);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    };
});
/* istanbul ignore next */
local.testRun = function (event) {
    var reader, tmp;
    switch (event &amp;&amp; event.currentTarget.id) {
    case &#x27;nedbExportButton1&#x27;:
        tmp = window.URL.createObjectURL(new window.Blob([local.Nedb.<span class="docApiCodeKeywordSpan">dbExport</span>()]));
        document.querySelector(&#x27;#nedbExportA1&#x27;).href = tmp;
        document.querySelector(&#x27;#nedbExportA1&#x27;).click();
        setTimeout(function () {
            window.URL.revokeObjectURL(tmp);
        }, 30000);
        break;
    case &#x27;nedbImportButton1&#x27;:
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.dbImport" id="element.Nedb.dbImport">
            function <span class="docApiSignatureSpan">Nedb.</span>dbImport
            <span class="docApiSignatureSpan">(tableList, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">dbImport = function (tableList, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will import the serialized tableList
 */
</span>    var onParallel;
    onParallel = function () {
        onParallel.counter -= 1;
        if (onParallel.counter === 0) {
            onError();
        }
    };
    onParallel.counter = 0;
    onParallel.counter += 1;
    tableList.trim().split(&#x27;\n\n&#x27;).forEach(function (table) {
        onParallel.counter += 1;
        local.dbTableCreate({
            persistenceData: table,
            name: JSON.parse((/.*/).exec(table)[0])
        }, onParallel);
    });
    onParallel();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    console.log(&#x27;importing nedb-database ...&#x27;);
    reader = new window.FileReader();
    tmp = document.querySelector(&#x27;#nedbImportInput1&#x27;).files[0];
    if (!tmp) {
        return;
    }
    reader.addEventListener(&#x27;load&#x27;, function () {
        local.Nedb.<span class="docApiCodeKeywordSpan">dbImport</span>(reader.result, function () {
            console.log(&#x27;... imported nedb-database&#x27;);
        });
    });
    reader.readAsText(tmp);
    break;
case &#x27;nedbResetButton1&#x27;:
    document.querySelector(&#x27;#outputTextarea1&#x27;).value = &#x27;&#x27;;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.dbReset" id="element.Nedb.dbReset">
            function <span class="docApiSignatureSpan">Nedb.</span>dbReset
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">dbReset = function (onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will reset nedb&#x27;s persistence
 */
</span>    var onParallel;
    onParallel = function () {
        onParallel.counter -= 1;
        if (onParallel.counter === 0) {
            onError();
        }
    };
    onParallel.counter = 0;
    onParallel.counter += 1;
    // drop all tables
    Object.keys(local.dbTableDict).forEach(function (key) {
        onParallel.counter += 1;
        local.dbTableDrop({ name: key }, onParallel);
    });
    onParallel.counter += 1;
    local.storeClear(onParallel);
    onParallel();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        });
    });
    reader.readAsText(tmp);
    break;
case &#x27;nedbResetButton1&#x27;:
    document.querySelector(&#x27;#outputTextarea1&#x27;).value = &#x27;&#x27;;
    console.log(&#x27;resetting nedb-database ...&#x27;);
    local.Nedb.<span class="docApiCodeKeywordSpan">dbReset</span>(function () {
        console.log(&#x27;... resetted nedb-database&#x27;);
    });
    break;
case &#x27;testRunButton1&#x27;:
    local.modeTest = true;
    local.utility2.testRun(local);
    break;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.dbTableCreate" id="element.Nedb.dbTableCreate">
            function <span class="docApiSignatureSpan">Nedb.</span>dbTableCreate
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">dbTableCreate = function (options, onError) {
    var self;
    self = local.dbTableDict[options.name];
    if (self) {
        setTimeout(function () {
            self.load(options, onError);
        });
        return self;
    }
    return new local.Nedb(options, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    &lt;label&gt;edit or paste script below to\n\
        &lt;a\n\
            href=&quot;https://kaizhu256.github.io/node-nedb-lite/build/doc.api.html&quot;\n\
            target=&quot;_blank&quot;\n\
        &gt;eval&lt;/a&gt;\n\
    &lt;/label&gt;\n\
&lt;textarea class=&quot;onkeyup&quot; id=&quot;inputTextarea1&quot;&gt;\n\
window.table1 = window.Nedb.<span class="docApiCodeKeywordSpan">dbTableCreate</span>({ name: &quot;table1&quot; });\n\
table1.insert({ field1: &quot;hello&quot;, field2: &quot;world&quot;}, function () {\n\
    console.log();\n\
    console.log(table1.export());\n\
});\n\
\n\
window.table2 = window.Nedb.dbTableCreate({ name: &quot;table2&quot; });\n\
table2.insert({ field1: &quot;hello&quot;, field2: &quot;world&quot;}, function () {\n\
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.dbTableDrop" id="element.Nedb.dbTableDrop">
            function <span class="docApiSignatureSpan">Nedb.</span>dbTableDrop
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">dbTableDrop = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will drop the table with the given options.name
 */
</span>    var self;
    self = local.dbTableDict[options.name];
    if (!self) {
        onError();
        return;
    }
    delete local.dbTableDict[options.name];
    self.persistence = self.prototype = self;
    self.persistCachedDatabase = self.persistNewState = function () {
        var ii;
        // coverage-hack
        for (ii = -1; ii &lt; arguments.length; ii += 1) {
            if (typeof arguments[ii] === &#x27;function&#x27;) {
                arguments[ii]();
                return;
            }
        }
    };
    local.storeRemoveItem(self.name, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
local.testCase_dbTableDrop_default = function (options, onError) {
/*
 * this function will test dbTableDrop&#x27;s default handling-behavior
 */
    options = {};
    options.name = &#x27;testCase_dbTableDrop_default&#x27;;
    options.table = local.dbTableCreate(options);
    local.<span class="docApiCodeKeywordSpan">dbTableDrop</span>(options.table, onError);
    // test undefined-table handling-behavior
    local.dbTableDrop(options.table, local.utility2.onErrorDefault);
};

local.testCase_dbTableFindOneById_default = function (options, onError) {
/*
 * this function will test dbTableFindOneById&#x27;s default handling-behavior
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.executor" id="element.Nedb.executor">
            function <span class="docApiSignatureSpan">Nedb.</span>executor
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Executor() {
    this.buffer = [];
    this.ready = false;

    // This queue will execute all commands, one-by-one in order
    this.queue = local.asyncQueue(function (task, cb) {
        var newArguments = [];

        // task.arguments is an array-like object on which adding a new field doesn&#x27;t work, so we transform it into a real array
        for (var i = 0; i &lt; task.arguments.length; i += 1) {
            newArguments.push(task.arguments[i]);
        }
        var lastArg = task.arguments[task.arguments.length - 1];

        // Always tell the queue task is complete. Execute callback if any was given.
        if (typeof lastArg === &#x27;function&#x27;) {
            // Callback was supplied
            newArguments[newArguments.length - 1] = function () {
                if (typeof setImmediate === &#x27;function&#x27;) {
                    setImmediate(cb);
                } else {
                    setTimeout(cb);
                }
                lastArg.apply(null, arguments);
            };
        } else if (!lastArg &amp;&amp; task.arguments.length !== 0) {
            // false/undefined/null supplied as callbback
            newArguments[newArguments.length - 1] = function () {
                cb();
            };
        } else {
            // Nothing supplied as callback
            newArguments.push(function () {
                cb();
            });
        }


        task.fn.apply(task.this, newArguments);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.fsDir" id="element.Nedb.fsDir">
            function <span class="docApiSignatureSpan">Nedb.</span>fsDir
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">fsDir = function () {
<span class="docApiCodeCommentSpan">/*
 * this function will return the persistence-dir
 */
</span>    if (local.fsDirInitialized) {
        return local.fsDirInitialized;
    }
    local.fsDirInitialized = &#x27;tmp/nedb.persistence.&#x27; + local.NODE_ENV;
    // mkdirp fsDirInitialized
    local.child_process.spawnSync(&#x27;mkdir&#x27;, [&#x27;-p&#x27;, local.fsDirInitialized], {
        stdio: [&#x27;ignore&#x27;, 1, 2]
    });
    return local.fsDirInitialized;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    switch (local.modeJs) {



    // run node js-env code - function
    case &#x27;node&#x27;:
local.storeClear = function (onError) {
    local.child_process.spawn(&#x27;sh&#x27;, [&#x27;-c&#x27;, &#x27;rm &#x27; + local.<span class="docApiCodeKeywordSpan">fsDir\
</span>() + &#x27;/*&#x27;], {
        stdio: [&#x27;ignore&#x27;, 1, 2]
    }).once(&#x27;exit&#x27;, onError);
};

local.storeGetItem = function (key, onError) {
    local.assert(typeof key === &#x27;string&#x27;);
    local.fs.readFile(
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.indexes" id="element.Nedb.indexes">
            function <span class="docApiSignatureSpan">Nedb.</span>indexes
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Index(options) {
    this.fieldName = options.fieldName;
    this.unique = options.unique || false;
    this.sparse = options.sparse || false;

    this.treeOptions = { unique: this.unique };

    this.reset(); // No data in the beginning
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.inherits" id="element.Nedb.inherits">
            function <span class="docApiSignatureSpan">Nedb.</span>inherits
            <span class="docApiSignatureSpan">(ctor, superCtor)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">inherits = function (ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...

}


/**
 * Inherit basic functions from the basic binary search tree
 */
local.<span class="docApiCodeKeywordSpan">inherits</span>(_AVLTree, BinarySearchTree);

/**
 * Keep a pointer to the internal tree constructor for testing purposes
 */
AVLTree._AVLTree = _AVLTree;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.isDate" id="element.Nedb.isDate">
            function <span class="docApiSignatureSpan">Nedb.</span>isDate
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">isDate = function (obj) {
    return Object.prototype.toString.call(obj) === &#x27;[object Date]&#x27;;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    : modeNext + 1;
switch (modeNext) {
// STEP 1: get candidates list by checking indexes from most to least frequent usecase
case 1:
    // For a basic match
    usableQueryKeys = [];
    Object.keys(query).forEach(function (k) {
        if (typeof query[k] === &#x27;string&#x27; || typeof query[k] === &#x27;number&#x27; || typeof query[k] === &#x27;boolea\
n&#x27; || local.<span class="docApiCodeKeywordSpan">isDate</span>(query[k]) || query[k] === null) {
            usableQueryKeys.push(k);
        }
    });
    usableQueryKeys = usableQueryKeys.filter(function (element) {
        return self.indexes.hasOwnProperty(element);
    });
    if (usableQueryKeys.length &gt; 0) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.isRegExp" id="element.Nedb.isRegExp">
            function <span class="docApiSignatureSpan">Nedb.</span>isRegExp
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === &#x27;[object RegExp]&#x27;;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    throw new Error(&quot;$nin operator called with a non-array&quot;);
}

return !comparisonFunctions.$in(a, b);
            };

            comparisonFunctions.$regex = function(a, b) {
if (!local.<span class="docApiCodeKeywordSpan">isRegExp</span>(b)) {
    throw new Error(&quot;$regex operator called with non regular expression&quot;);
}

if (typeof a !== &#x27;string&#x27;) {
    return false
} else {
    return b.test(a);
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.jsonStringifyOrdered" id="element.Nedb.jsonStringifyOrdered">
            function <span class="docApiSignatureSpan">Nedb.</span>jsonStringifyOrdered
            <span class="docApiSignatureSpan">(element, replacer, space)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">jsonStringifyOrdered = function (element, replacer, space) {
<span class="docApiCodeCommentSpan">/*
 * this function will JSON.stringify the element,
 * with object-keys sorted and circular-references removed
 */
</span>    var circularList, stringify, tmp;
    stringify = function (element) {
    /*
     * this function will recursively JSON.stringify the element,
     * with object-keys sorted and circular-references removed
     */
        // if element is an object, then recurse its items with object-keys sorted
        if (element &amp;&amp;
                typeof element === &#x27;object&#x27; &amp;&amp;
                typeof element.toJSON !== &#x27;function&#x27;) {
            // ignore circular-reference
            if (circularList.indexOf(element) &gt;= 0) {
                return;
            }
            circularList.push(element);
            // if element is an array, then recurse its elements
            if (Array.isArray(element)) {
                return &#x27;[&#x27; + element.map(function (element) {
                    tmp = stringify(element);
                    return typeof tmp === &#x27;string&#x27;
                        ? tmp
                        : &#x27;null&#x27;;
                }).join(&#x27;,&#x27;) + &#x27;]&#x27;;
            }
            return &#x27;{&#x27; + Object.keys(element)
                // sort object-keys
                .sort()
                .map(function (key) {
                    tmp = stringify(element[key]);
                    return typeof tmp === &#x27;string&#x27;
                        ? JSON.stringify(key) + &#x27;:&#x27; + tmp
                        : undefined;
                })
                .filter(function (element) {
                    return typeof element === &#x27;string&#x27;;
                })
                .join(&#x27;,&#x27;) + &#x27;}&#x27;;
        }
        // else JSON.stringify as normal
        return JSON.stringify(element);
    };
    circularList = [];
    return JSON.stringify(element &amp;&amp; typeof element === &#x27;object&#x27;
        ? JSON.parse(stringify(element))
        : element, replacer, space);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    console[&#x27;_&#x27; + key] = console[key];
    console[key] = function () {
        console[&#x27;_&#x27; + key].apply(console, arguments);
        document.querySelector(&#x27;#outputTextarea1&#x27;).value +=
            Array.prototype.slice.call(arguments).map(function (arg) {
                return typeof arg === &#x27;string&#x27;
                    ? arg
                    : local.Nedb.<span class="docApiCodeKeywordSpan">jsonStringifyOrdered</span>(arg, null, 4);
            }).join(&#x27; &#x27;) + &#x27;\n&#x27;;
    };
});
/* istanbul ignore next */
local.testRun = function (event) {
    var reader, tmp;
    switch (event &amp;&amp; event.currentTarget.id) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.listUnique" id="element.Nedb.listUnique">
            function <span class="docApiSignatureSpan">Nedb.</span>listUnique
            <span class="docApiSignatureSpan">(list)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">listUnique = function (list) {
<span class="docApiCodeCommentSpan">/*
 * this function will remove duplicate elements from the array
 */
</span>    var seen;
    seen = {};
    return list.filter(function (element) {
        if (seen.hasOwnProperty(element)) {
            return;
        }
        seen[element] = true;
        return true;
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
return;
                }

                if (!Array.isArray(key)) {
this.tree.insert(key, doc);
                } else {
// If an insert fails due to a unique constraint, roll back all inserts before it
keys = local.<span class="docApiCodeKeywordSpan">listUnique</span>(key).map(projectForUnique);

for (i = 0; i &lt; keys.length; i += 1) {
    try {
        this.tree.insert(keys[i], doc);
    } catch (e) {
        error = e;
        failingI = i;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.local" id="element.Nedb.local">
            function <span class="docApiSignatureSpan">Nedb.</span>local
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">local = function (options, onError) {
<span class="docApiCodeCommentSpan">/**
 * Create a new collection
 * @param {String} options.name
 * @param {Function} onError Optional,
 * if autoload is used this will be called after the load database
 * with the error object as parameter. If you don&#x27;t pass it the error will be thrown
 */
</span>    // validate name
    if (!(options &amp;&amp; options.name &amp;&amp; typeof options.name === &#x27;string&#x27;)) {
        throw new Error(&#x27;Nedb - missing name param, e.g. new Nedb({ name: &quot;table1&quot; })&#x27;);
    }
    this.name = options.name;
    local.dbTableDrop(this, local.nop);
    local.dbTableDict[this.name] = this;
    // Persistence handling
    this.persistence = new local.Persistence({ db: this });
    // This new executor is ready if we don&#x27;t use persistence
    // If we do, it will only be ready once loadDatabase is called
    this.executor = new local.Executor();
    // Indexed by field name, dot notation can be used
    // _id is always indexed and since _ids are generated randomly the underlying
    // binary is always well-balanced
    this.indexes = {
        _id: new local.Index({ fieldName: &#x27;_id&#x27;, unique: true }),
        createdAt: new local.Index({ fieldName: &#x27;createdAt&#x27; }),
        updatedAt: new local.Index({ fieldName: &#x27;updatedAt&#x27; })
    };
    this.ttlIndexes = {};
    this.load(options, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.middleware" id="element.Nedb.middleware">
            function <span class="docApiSignatureSpan">Nedb.</span>middleware
            <span class="docApiSignatureSpan">(request, response, nextMiddleware)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">middleware = function (request, response, nextMiddleware) {
    var options;
    options = {};
    local.utility2.onNext(options, function (error) {
        // recurse with next middleware in middlewareList
        if (options.modeNext &lt; self.middlewareList.length) {
            // run the sub-middleware
            self.middlewareList[options.modeNext](
                request,
                response,
                options.onNext
            );
            return;
        }
        // default to nextMiddleware
        nextMiddleware(error);
    });
    options.modeNext = -1;
    options.onNext();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.middlewareError" id="element.Nedb.middlewareError">
            function <span class="docApiSignatureSpan">Nedb.</span>middlewareError
            <span class="docApiSignatureSpan">(error, request, response)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">middlewareError = function (error, request, response) {
<span class="docApiCodeCommentSpan">/*
 * this function will run the middleware that will handle errors
 */
</span>    // if error occurred, then respond with &#x27;500 Internal Server Error&#x27;,
    // else respond with &#x27;404 Not Found&#x27;
    local.utility2.serverRespondDefault(request, response, error
        ? (error.statusCode &gt;= 400 &amp;&amp; error.statusCode &lt; 600
            ? error.statusCode
            : 500)
        : 404, error);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.nop" id="element.Nedb.nop">
            function <span class="docApiSignatureSpan">Nedb.</span>nop
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">nop = function () {
<span class="docApiCodeCommentSpan">/*
 * this function will do nothing
 */
</span>    return;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
};

local.testCase_dbImport_default = function (options, onError) {
/*
 * this function will test dbImport&#x27;s default handling-behavior
 */
    // jslint-hack
    local.utility2.<span class="docApiCodeKeywordSpan">nop</span>(options);
    local.dbImport(&#x27;&quot;testCase_dbImport_default&quot;\n{&quot;id&quot;:0}&#x27;, onError);
};

local.testCase_dbTableCreate_default = function (options, onError) {
/*
 * this function will test dbTableCreate&#x27;s default handling-behavior
 */
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.persistence" id="element.Nedb.persistence">
            function <span class="docApiSignatureSpan">Nedb.</span>persistence
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Persistence(options) {
    var i, j, randomString;

    this.db = options.db;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.sortCompare" id="element.Nedb.sortCompare">
            function <span class="docApiSignatureSpan">Nedb.</span>sortCompare
            <span class="docApiSignatureSpan">(aa, bb)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">sortCompare = function (aa, bb) {
<span class="docApiCodeCommentSpan">/*
 * this function will sort-compare aa vs bb
 */
</span>    var type1, type2;
    // compare equal
    if (aa === bb) {
        return 0;
    }
    // compare undefined
    if (aa === undefined) {
        return -1;
    }
    if (bb === undefined) {
        return 1;
    }
    // compare null
    if (aa === null) {
        return -1;
    }
    if (bb === null) {
        return 1;
    }
    // compare different-types
    type1 = typeof aa;
    type2 = typeof bb;
    if (type1 !== type2) {
        if (type1 === &#x27;boolean&#x27;) {
            return -1;
        }
        if (type2 === &#x27;boolean&#x27;) {
            return 1;
        }
        if (type1 === &#x27;number&#x27;) {
            return -1;
        }
        if (type2 === &#x27;number&#x27;) {
            return 1;
        }
        if (type1 === &#x27;string&#x27;) {
            return -1;
        }
        if (type2 === &#x27;string&#x27;) {
            return 1;
        }
    }
    // default compare
    return aa &lt; bb
        ? -1
        : aa &gt; bb
        ? 1
        : 0;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        direction: self._sort[key]
    });
}
res.sort(function (a, b) {
    var criterion, compare, i;
    for (i = 0; i &lt; criteria.length; i++) {
        criterion = criteria[i];
        compare = criterion.direction * local.<span class="docApiCodeKeywordSpan">sortCompare</span>(model.getDotValue(a, criter\
ion.key), model.getDotValue(b, criterion.key));
        if (compare !== 0) {
            return compare;
        }
    }
    return 0;
});
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeAction" id="element.Nedb.storeAction">
            function <span class="docApiSignatureSpan">Nedb.</span>storeAction
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeAction = function (options, onError) {
    var argList, data, done, onError2, request, store;
    if (!local.store) {
        argList = arguments;
        local.storePromiseList.push(function () {
            local.storeAction.apply(null, argList);
        });
        return;
    }
    onError2 = function () {
        if (done) {
            return;
        }
        done = true;
        onError(
            request &amp;&amp; (request.error || request.transaction.error),
            data || request.result
        );
    };
    switch (options.action) {
    case &#x27;clear&#x27;:
    case &#x27;removeItem&#x27;:
    case &#x27;setItem&#x27;:
        store = local.store.transaction(&#x27;nedbdata&#x27;, &#x27;readwrite&#x27;).objectStore(&#x27;nedbdata&#x27;);
        break;
    default:
        store = local.store.transaction(&#x27;nedbdata&#x27;, &#x27;readonly&#x27;).objectStore(&#x27;nedbdata&#x27;);
    }
    switch (options.action) {
    case &#x27;clear&#x27;:
        request = store.clear();
        break;
    case &#x27;getItem&#x27;:
        request = store.get(options.key);
        break;
    case &#x27;keys&#x27;:
        data = [];
        request = store.openCursor();
        request.onsuccess = function () {
            if (!request.result) {
                onError2();
                return;
            }
            data.push(request.result.key);
            request.result.continue();
        };
        break;
    case &#x27;length&#x27;:
        request = store.count();
        break;
    case &#x27;removeItem&#x27;:
        request = store.delete(options.key);
        break;
    case &#x27;setItem&#x27;:
        request = store.put(options.value, options.key);
        break;
    }
    [&#x27;onabort&#x27;, &#x27;onerror&#x27;, &#x27;onsuccess&#x27;].forEach(function (handler) {
        request[handler] = request[handler] || onError2;
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    }
    [&#x27;onabort&#x27;, &#x27;onerror&#x27;, &#x27;onsuccess&#x27;].forEach(function (handler) {
        request[handler] = request[handler] || onError2;
    });
};

local.storeClear = function (onError) {
    local.<span class="docApiCodeKeywordSpan">storeAction</span>({ action: &#x27;clear&#x27; }, onError);
};

local.storeGetItem = function (key, onError) {
    local.assert(typeof key === &#x27;string&#x27;);
    local.storeAction({ action: &#x27;getItem&#x27;, key: key }, onError);
};
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeClear" id="element.Nedb.storeClear">
            function <span class="docApiSignatureSpan">Nedb.</span>storeClear
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeClear = function (onError) {
    local.child_process.spawn(&#x27;sh&#x27;, [&#x27;-c&#x27;, &#x27;rm &#x27; + local.fsDir() + &#x27;/*&#x27;], {
        stdio: [&#x27;ignore&#x27;, 1, 2]
    }).once(&#x27;exit&#x27;, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    onParallel.counter += 1;
    // drop all tables
    Object.keys(local.dbTableDict).forEach(function (key) {
        onParallel.counter += 1;
        local.dbTableDrop({ name: key }, onParallel);
    });
    onParallel.counter += 1;
    local.<span class="docApiCodeKeywordSpan">storeClear</span>(onParallel);
    onParallel();
};

local.dbTableCreate = function (options, onError) {
    var self;
    self = local.dbTableDict[options.name];
    if (self) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeGetItem" id="element.Nedb.storeGetItem">
            function <span class="docApiSignatureSpan">Nedb.</span>storeGetItem
            <span class="docApiSignatureSpan">(key, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeGetItem = function (key, onError) {
    local.assert(typeof key === &#x27;string&#x27;);
    local.fs.readFile(
        local.fsDir() + &#x27;/&#x27; + encodeURIComponent(key),
        &#x27;utf8&#x27;,
        function (error, data) {
            // jslint-hack
            local.nop(error);
            onError(null, data || &#x27;&#x27;);
        }
    );
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        toPersist += model.serialize(doc) + &#x27;\n&#x27;;
    });

    if (toPersist.length === 0) {
        return callback();
    }

    local.<span class="docApiCodeKeywordSpan">storeGetItem</span>(self.db.name, function (error, data) {
        local.storeSetItem(self.db.name, (data || &#x27;&#x27;) + toPersist, callback);
    });
};


/**
 * From a database&#x27;s raw data, return the corresponding
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeInit" id="element.Nedb.storeInit">
            function <span class="docApiSignatureSpan">Nedb.</span>storeInit
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeInit = function () {
    var modeNext, onNext, request;
    if (!local.global.indexedDB) {
        return;
    }
    modeNext = 0;
    onNext = function (error) {
        local.store = local.global.nedbStore;
        // validate no error occurred
        local.assert(local.store || !error, error);
        modeNext += 1;
        switch (modeNext) {
        // init indexedDB
        case 1:
            if (local.store) {
                onNext();
                return;
            }
            request = local.global.indexedDB.open(&#x27;NeDB&#x27;);
            request.onerror = function () {
                onNext(request.error);
            };
            request.onsuccess = function () {
                local.global.nedbStore = request.result;
                onNext();
            };
            request.onupgradeneeded = function () {
                if (!request.result.objectStoreNames.contains(&#x27;nedbdata&#x27;)) {
                    request.result.createObjectStore(&#x27;nedbdata&#x27;);
                }
            };
            break;
        // run promised actions
        case 2:
            while (local.storePromiseList.length) {
                local.storePromiseList.shift()();
            }
            break;
        }
    };
    onNext();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
/* jslint-ignore-end */



// run shared js-env code - post-init
(function () {
    // init indexedDB store
    local.<span class="docApiCodeKeywordSpan">storeInit</span>();
    // re-init local
    Object.keys(local).forEach(function (key) {
        local[key.replace((/.*\//), &#x27;&#x27;)] = local[key];
    });
}());
switch (local.modeJs) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeKeys" id="element.Nedb.storeKeys">
            function <span class="docApiSignatureSpan">Nedb.</span>storeKeys
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeKeys = function (onError) {
    local.fs.readdir(local.fsDir(), function (error, data) {
        onError(error, data &amp;&amp; data.map(decodeURIComponent));
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeLength" id="element.Nedb.storeLength">
            function <span class="docApiSignatureSpan">Nedb.</span>storeLength
            <span class="docApiSignatureSpan">(onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeLength = function (onError) {
    local.fs.readdir(local.fsDir(), function (error, data) {
        onError(error, data &amp;&amp; data.length);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeRemoveItem" id="element.Nedb.storeRemoveItem">
            function <span class="docApiSignatureSpan">Nedb.</span>storeRemoveItem
            <span class="docApiSignatureSpan">(key, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeRemoveItem = function (key, onError) {
    local.assert(typeof key === &#x27;string&#x27;);
    local.fs.unlink(local.fsDir() + &#x27;/&#x27; + encodeURIComponent(key), function (error) {
        // jslint-hack
        local.nop(error);
        onError();
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        for (ii = -1; ii &lt; arguments.length; ii += 1) {
            if (typeof arguments[ii] === &#x27;function&#x27;) {
                arguments[ii]();
                return;
            }
        }
    };
    local.<span class="docApiCodeKeywordSpan">storeRemoveItem</span>(self.name, onError);
};

local.fsDir = function () {
/*
 * this function will return the persistence-dir
 */
    if (local.fsDirInitialized) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.storeSetItem" id="element.Nedb.storeSetItem">
            function <span class="docApiSignatureSpan">Nedb.</span>storeSetItem
            <span class="docApiSignatureSpan">(key, value, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">storeSetItem = function (key, value, onError) {
    var tmp;
    local.assert(typeof key === &#x27;string&#x27;);
    local.assert(typeof value === &#x27;string&#x27;);
    tmp = local.os.tmpdir() + &#x27;/&#x27; + Date.now() + Math.random();
    // save to tmp
    local.fs.writeFile(tmp, value, function (error) {
        // jslint-hack
        local.nop(error);
        // rename tmp to key
        local.fs.rename(tmp, local.fsDir() + &#x27;/&#x27; + encodeURIComponent(key), onError);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    if (!data) {
        onNext();
        return;
    }
    self.isLoaded = null;
    data += &#x27;\n&#x27;;
    data = data.slice(data.indexOf(&#x27;\n&#x27;) + 1);
    local.<span class="docApiCodeKeywordSpan">storeSetItem</span>(self.name, data, onNext);
    break;
case 2:
    if (self.isLoaded) {
        onNext();
        return;
    }
    self.isLoaded = true;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_assertXxx_default" id="element.Nedb.testCase_assertXxx_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_assertXxx_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_assertXxx_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test assertXxx&#x27;s default handling-behavior
 */
</span>    options = {};
    // test assertion passed
    local.utility2.assert(true, true);
    // test assertion failed with undefined message
    local.utility2.tryCatchOnError(function () {
        local.utility2.assert(false);
    }, function (error) {
        // validate error occurred
        local.utility2.assert(error, error);
        // validate error-message
        local.utility2.assertJsonEqual(error.message, &#x27;&#x27;);
    });
    // test assertion failed with string message
    local.utility2.tryCatchOnError(function () {
        local.utility2.assert(false, &#x27;hello&#x27;);
    }, function (error) {
        // validate error occurred
        local.utility2.assert(error, error);
        // validate error-message
        local.utility2.assertJsonEqual(error.message, &#x27;hello&#x27;);
    });
    // test assertion failed with error object
    local.utility2.tryCatchOnError(function () {
        local.utility2.assert(false, local.utility2.errorDefault);
    }, function (error) {
        // validate error occurred
        local.utility2.assert(error, error);
    });
    // test assertion failed with json object
    local.utility2.tryCatchOnError(function () {
        local.utility2.assert(false, { aa: 1 });
    }, function (error) {
        // validate error occurred
        local.utility2.assert(error, error);
        // validate error-message
        local.utility2.assertJsonEqual(error.message, &#x27;{&quot;aa&quot;:1}&#x27;);
    });
    options.list = [&#x27;&#x27;, 0, false, null, undefined];
    options.list.forEach(function (aa, ii) {
        options.list.forEach(function (bb, jj) {
            if (ii === jj) {
                // test assertJsonEqual&#x27;s handling-behavior
                local.utility2.assertJsonEqual(aa, bb);
            } else {
                // test assertJsonNotEqual&#x27;s handling-behavior
                local.utility2.assertJsonNotEqual(aa, bb);
            }
        });
    });
    onError();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_build_app" id="element.Nedb.testCase_build_app">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_build_app
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_build_app = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test build&#x27;s app handling-behavior
 */
</span>    var onParallel;
    onParallel = local.utility2.onParallel(onError);
    onParallel.counter += 1;
    options = {};
    options = [{
        file: &#x27;/assets.app.js&#x27;,
        url: &#x27;/assets.app.js&#x27;
    }, {
        file: &#x27;/assets.app.min.js&#x27;,
        url: &#x27;/assets.app.min.js&#x27;
    }, {
        file: &#x27;/assets.example.js&#x27;,
        url: &#x27;/assets.example.js&#x27;
    }, {
        file: &#x27;/assets.&#x27; + local.utility2.envDict.npm_package_name + &#x27;.css&#x27;,
        url: &#x27;/assets.&#x27; + local.utility2.envDict.npm_package_name + &#x27;.css&#x27;
    }, {
        file: &#x27;/assets.&#x27; + local.utility2.envDict.npm_package_name + &#x27;.js&#x27;,
        url: &#x27;/assets.&#x27; + local.utility2.envDict.npm_package_name + &#x27;.js&#x27;
    }, {
        file: &#x27;/assets.&#x27; + local.utility2.envDict.npm_package_name + &#x27;.min.js&#x27;,
        transform: function (data) {
            return local.utility2.uglifyIfProduction(
                local.utility2.bufferToString(data)
            );
        },
        url: &#x27;/assets.&#x27; + local.utility2.envDict.npm_package_name + &#x27;.js&#x27;
    }, {
        file: &#x27;/assets.test.js&#x27;,
        url: &#x27;/assets.test.js&#x27;
    }, {
        file: &#x27;/assets.utility2.rollup.js&#x27;,
        url: &#x27;/assets.utility2.rollup.js&#x27;
    }, {
        file: &#x27;/index.html&#x27;,
        url: &#x27;/index.html&#x27;
    }, {
        file: &#x27;/jsonp.utility2.stateInit&#x27;,
        url: &#x27;/jsonp.utility2.stateInit?callback=window.utility2.stateInit&#x27;
    }];
    options.forEach(function (options) {
        onParallel.counter += 1;
        local.utility2.ajax(options, function (error, xhr) {
            onParallel.counter += 1;
            // validate no error occurred
            onParallel(error);
            switch (local.path.extname(options.file)) {
            case &#x27;.css&#x27;:
            case &#x27;.js&#x27;:
            case &#x27;.json&#x27;:
                local.utility2.jslintAndPrintConditional(
                    xhr.responseText,
                    options.file
                );
                // validate no error occurred
                local.utility2.assert(
                    !local.utility2.jslint.errorText,
                    local.utility2.jslint.errorText
                );
                break;
            }
            local.utility2.fsWriteFileWithMkdirp(
                local.utility2.envDict.npm_config_dir_build + &#x27;/app&#x27; + options.file,
                (options.transform || local.utility2.echo)(xhr.response),
                onParallel
            );
        });
    });
    onParallel();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_build_doc" id="element.Nedb.testCase_build_doc">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_build_doc
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_build_doc = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test build&#x27;s doc handling-behavior
 */
</span>    options = {};
    local.utility2.onNext(options, function (error) {
        switch (options.modeNext) {
        case 1:
            options.moduleDict = {
                Nedb: {
                    exampleList: [],
                    exports: local.Nedb
                },
                &#x27;Nedb.customUtils&#x27;: {
                    exampleList: [],
                    exports: local.Nedb.customUtils
                },
                &#x27;Nedb.model&#x27;: {
                    exampleList: [],
                    exports: local.Nedb.model
                },
                &#x27;Nedb.persistence&#x27;: {
                    exampleList: [],
                    exports: local.Nedb.persistence
                },
                &#x27;Nedb.persistence.prototype&#x27;: {
                    exampleList: [],
                    exports: local.Nedb.persistence.prototype
                },
                &#x27;Nedb.prototype&#x27;: {
                    exampleList: [],
                    exports: local.Nedb.prototype
                }
            };
            Object.keys(options.moduleDict).forEach(function (key) {
                options.moduleDict[key].example = [
                    &#x27;README.md&#x27;,
                    &#x27;test.js&#x27;,
                    &#x27;index.js&#x27;
                ]
                    .concat(options.moduleDict[key].exampleList)
                    .map(function (file) {
                        return &#x27;\n\n\n\n\n\n\n\n&#x27; +
                            local.fs.readFileSync(file, &#x27;utf8&#x27;) +
                            &#x27;\n\n\n\n\n\n\n\n&#x27;;
                    }).join(&#x27;&#x27;);
            });
            // create doc.api.html
            local.utility2.fsWriteFileWithMkdirp(
                local.utility2.envDict.npm_config_dir_build + &#x27;/doc.api.html&#x27;,
                local.utility2.docApiCreate(options),
                options.onNext
            );
            break;
        case 2:
            local.utility2.browserTest({
                modeBrowserTest: &#x27;screenCapture&#x27;,
                url: &#x27;file://&#x27; + local.utility2.envDict.npm_config_dir_build +
                    &#x27;/doc.api.html&#x27;
            }, options.onNext);
            break;
        default:
            onError(error);
        }
    });
    options.modeNext = 0;
    options.onNext();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbExport_default" id="element.Nedb.testCase_dbExport_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbExport_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbExport_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbExport&#x27;s default handling-behavior
 */
</span>    options = {};
    options.name = &#x27;testCase_dbExport_default&#x27;;
    options.table = local.dbTableCreate(options);
    options.table.ensureIndex({
        fieldName: &#x27;id&#x27;,
        unique: true
    }, local.utility2.onErrorDefault);
    options.data = local.dbExport();
    // validate data
    local.utility2.assert(options.data.indexOf(&#x27;&quot;testCase_dbExport_default&quot;\n&#x27; +
        &#x27;{&quot;$$indexCreated&quot;:{&quot;fieldName&quot;:&quot;createdAt&quot;,&quot;unique&quot;:false,&quot;sparse&quot;:false}}\n&#x27; +
        &#x27;{&quot;$$indexCreated&quot;:{&quot;fieldName&quot;:&quot;updatedAt&quot;,&quot;unique&quot;:false,&quot;sparse&quot;:false}}\n&#x27; +
        &#x27;{&quot;$$indexCreated&quot;:{&quot;fieldName&quot;:&quot;id&quot;,&quot;unique&quot;:true,&quot;sparse&quot;:false}}&#x27;)
        &gt;= 0, options.data);
    onError();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbImport_default" id="element.Nedb.testCase_dbImport_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbImport_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbImport_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbImport&#x27;s default handling-behavior
 */
</span>    // jslint-hack
    local.utility2.nop(options);
    local.dbImport(&#x27;&quot;testCase_dbImport_default&quot;\n{&quot;id&quot;:0}&#x27;, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbTableCreate_default" id="element.Nedb.testCase_dbTableCreate_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableCreate_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbTableCreate_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbTableCreate&#x27;s default handling-behavior
 */
</span>    options = {};
    options.name = &#x27;testCase_dbTableCreate_default&#x27;;
    options.table = local.dbTableCreate(options);
    // test re-create handling-behavior
    options.table = local.dbTableCreate(options);
    // test reset handling-behavior
    options.reset = true;
    options.table = local.dbTableCreate(options);
    onError();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbTableCreate_error" id="element.Nedb.testCase_dbTableCreate_error">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableCreate_error
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbTableCreate_error = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbTableCreate&#x27;s error handling-behavior
 */
</span>    options = {};
    options.error = local.utility2.errorDefault;
    options.name = &#x27;testCase_dbTableCreate_error&#x27;;
    options.table = local.dbTableCreate(options, function (error) {
        // validate error occurred
        local.utility2.assert(error, error);
        onError();
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbTableDrop_default" id="element.Nedb.testCase_dbTableDrop_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableDrop_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbTableDrop_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbTableDrop&#x27;s default handling-behavior
 */
</span>    options = {};
    options.name = &#x27;testCase_dbTableDrop_default&#x27;;
    options.table = local.dbTableCreate(options);
    local.dbTableDrop(options.table, onError);
    // test undefined-table handling-behavior
    local.dbTableDrop(options.table, local.utility2.onErrorDefault);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbTableFindOneById_default" id="element.Nedb.testCase_dbTableFindOneById_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableFindOneById_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbTableFindOneById_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbTableFindOneById&#x27;s default handling-behavior
 */
</span>    options = {};
    local.utility2.onNext(options, function (error, data) {
        switch (options.modeNext) {
        case 1:
            options = local.crudOptionsSetDefault(options, {
                id: &#x27;00_test_dbTableFindOneById&#x27;
            });
            options.table.findOne({ id: options.id }, options.onNext);
            break;
        case 2:
            // validate data
            local.utility2.assertJsonEqual(data.id, options.id);
            options.onNext();
            break;
        default:
            onError(error);
        }
    });
    options.modeNext = 0;
    options.onNext();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
options = {};
local.utility2.onNext(options, function (error, data) {
    switch (options.modeNext) {
    case 1:
        options = local.crudOptionsSetDefault(options, {
            id: &#x27;00_test_dbTableRemoveOneById&#x27;
        });
        local.<span class="docApiCodeKeywordSpan">testCase_dbTableFindOneById_default</span>(options, options.onNext);
        break;
    case 2:
        options.table.remove({ id: options.id }, options.onNext);
        break;
    case 3:
        options.table.findOne({ id: options.id }, options.onNext);
        break;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_dbTableRemoveOneById_default" id="element.Nedb.testCase_dbTableRemoveOneById_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_dbTableRemoveOneById_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_dbTableRemoveOneById_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test dbTableRemoveOneById&#x27;s default handling-behavior
 */
</span>    options = {};
    local.utility2.onNext(options, function (error, data) {
        switch (options.modeNext) {
        case 1:
            options = local.crudOptionsSetDefault(options, {
                id: &#x27;00_test_dbTableRemoveOneById&#x27;
            });
            local.testCase_dbTableFindOneById_default(options, options.onNext);
            break;
        case 2:
            options.table.remove({ id: options.id }, options.onNext);
            break;
        case 3:
            options.table.findOne({ id: options.id }, options.onNext);
            break;
        case 4:
            // validate data was removed
            local.utility2.assertJsonEqual(data, null);
            options.onNext();
            break;
        default:
            onError(error, data);
        }
    });
    options.modeNext = 0;
    options.onNext();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_jsonStringifyOrdered_default" id="element.Nedb.testCase_jsonStringifyOrdered_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_jsonStringifyOrdered_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_jsonStringifyOrdered_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test jsonStringifyOrdered&#x27;s default handling-behavior
 */
</span>    options = {};
    // test data-type handling-behavior
    [undefined, null, false, true, 0, 1, 1.5, &#x27;a&#x27;, {}, []].forEach(function (data) {
        options.aa = local.utility2.jsonStringifyOrdered(data);
        options.bb = JSON.stringify(data);
        local.utility2.assertJsonEqual(options.aa, options.bb);
    });
    // test data-ordering handling-behavior
    options = {
        // test nested dict handling-behavior
        ff: { hh: 2, gg: 1},
        // test nested array handling-behavior
        ee: [1, null, undefined],
        dd: local.utility2.nop,
        cc: undefined,
        bb: null,
        aa: 1
    };
    // test circular-reference handling-behavior
    options.zz = options;
    local.utility2.assertJsonEqual(
        options,
        { aa: 1, bb: null, ee: [ 1, null, null ], ff: { gg: 1, hh: 2 } }
    );
    onError();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.testCase_webpage_default" id="element.Nedb.testCase_webpage_default">
            function <span class="docApiSignatureSpan">Nedb.</span>testCase_webpage_default
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">testCase_webpage_default = function (options, onError) {
<span class="docApiCodeCommentSpan">/*
 * this function will test the webpage&#x27;s default handling-behavior
 */
</span>    options = {
        modeCoverageMerge: true,
        url: local.utility2.serverLocalHost + &#x27;?modeTest=1&#x27;
    };
    local.utility2.browserTest(options, onError);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </div>
    
    <div class="docApiSectionDiv">
    <h1><a href="#module.Nedb.customUtils" id="module.Nedb.customUtils">module Nedb.customUtils</a></h1>
        
        
        <h2>
            <a href="#element.Nedb.customUtils.uid" id="element.Nedb.customUtils.uid">
            function <span class="docApiSignatureSpan">Nedb.customUtils.</span>uid
            <span class="docApiSignatureSpan">(len)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function uid(len) {
    return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\/]/g, &#x27;&#x27;).slice(0, len);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    });
};

/**
 * Create a new _id that&#x27;s not already in use
 */
Datastore.prototype.createNewId = function () {
    var tentativeId = customUtils.<span class="docApiCodeKeywordSpan">uid</span>(16);
    // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is \
extremely small, so this is O(1)
    if (this.indexes._id.getMatching(tentativeId).length &gt; 0) {
        tentativeId = this.createNewId();
    }
    return tentativeId;
};
...</pre></li>
        </ul>
        
        
    </div>
    
    <div class="docApiSectionDiv">
    <h1><a href="#module.Nedb.model" id="module.Nedb.model">module Nedb.model</a></h1>
        
        
        <h2>
            <a href="#element.Nedb.model.areThingsEqual" id="element.Nedb.model.areThingsEqual">
            function <span class="docApiSignatureSpan">Nedb.model.</span>areThingsEqual
            <span class="docApiSignatureSpan">(a, b)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function areThingsEqual(a, b) {
    var aKeys, bKeys, i;

    // Strings, booleans, numbers, null
    if (a === null || typeof a === &#x27;string&#x27; || typeof a === &#x27;boolean&#x27; || typeof a === &#x27;number&#x27; ||
        b === null || typeof b === &#x27;string&#x27; || typeof b === &#x27;boolean&#x27; || typeof b === &#x27;number&#x27;) {
        return a === b;
    }

    // Dates
    if (local.isDate(a) || local.isDate(b)) {
        return local.isDate(a) &amp;&amp; local.isDate(b) &amp;&amp; a.getTime() === b.getTime();
    }

    // Arrays (no match since arrays are used as a $in)
    // undefined (no match since they mean field doesn&#x27;t exist and can&#x27;t be serialized)
    if ((!(Array.isArray(a) &amp;&amp; Array.isArray(b)) &amp;&amp; (Array.isArray(a) || Array.isArray(b))) || a === undefined || b === undefine\
d) {
        return false;
    }

    // General objects (check for deep equality)
    // a and b should be objects at this point
    try {
        aKeys = Object.keys(a);
        bKeys = Object.keys(b);
    } catch (e) {
        return false;
    }

    if (aKeys.length !== bKeys.length) {
        return false;
    }
    for (i = 0; i &lt; aKeys.length; i += 1) {
        if (bKeys.indexOf(aKeys[i]) === -1) {
            return false;
        }
        if (!areThingsEqual(a[aKeys[i]], b[aKeys[i]])) {
            return false;
        }
    }
    return true;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.checkObject" id="element.Nedb.model.checkObject">
            function <span class="docApiSignatureSpan">Nedb.model.</span>checkObject
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function checkObject(obj) {
    if (Array.isArray(obj)) {
        obj.forEach(function(o) {
            checkObject(o);
        });
    }

    if (typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null) {
        Object.keys(obj).forEach(function(k) {
            checkKey(k, obj[k]);
            checkObject(obj[k]);
        });
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        var now = new Date().toISOString();
        if (preparedDoc.createdAt === undefined) {
            preparedDoc.createdAt = now;
        }
        if (preparedDoc.updatedAt === undefined) {
            preparedDoc.updatedAt = now;
        }
        model.<span class="docApiCodeKeywordSpan">checkObject</span>(preparedDoc);
    }

    return preparedDoc;
};

/**
 * If newDoc is an array of documents, this will insert all documents in the cache
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.deepCopy" id="element.Nedb.model.deepCopy">
            function <span class="docApiSignatureSpan">Nedb.model.</span>deepCopy
            <span class="docApiSignatureSpan">(obj, strictKeys)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function deepCopy(obj, strictKeys) {
    var res;

    if (typeof obj === &#x27;boolean&#x27; ||
        typeof obj === &#x27;number&#x27; ||
        typeof obj === &#x27;string&#x27; ||
        obj === null ||
        (local.isDate(obj))) {
        return obj;
    }

    if (Array.isArray(obj)) {
        res = [];
        obj.forEach(function(o) {
            res.push(deepCopy(o, strictKeys));
        });
        return res;
    }

    if (typeof obj === &#x27;object&#x27;) {
        res = {};
        Object.keys(obj).forEach(function(k) {
            if (!strictKeys || (k[0] !== &#x27;$&#x27; &amp;&amp; k.indexOf(&#x27;.&#x27;) === -1)) {
                res[k] = deepCopy(obj[k], strictKeys);
            }
        });
        return res;
    }

    return undefined; // For now everything else is undefined. We should probably throw an error instead
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        return callback(e);
    }

    this.persistence.persistNewState(Array.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (error) {
        if (error) {
            return callback(error);
        }
        return callback(null, model.<span class="docApiCodeKeywordSpan">deepCopy</span>(preparedDoc));
    });
};

/**
 * Create a new _id that&#x27;s not already in use
 */
Datastore.prototype.createNewId = function () {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.deserialize" id="element.Nedb.model.deserialize">
            function <span class="docApiSignatureSpan">Nedb.model.</span>deserialize
            <span class="docApiSignatureSpan">(rawData)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function deserialize(rawData) {
    return JSON.parse(rawData, function(k, v) {
        if (k === &#x27;$$date&#x27;) {
            return new Date(v).toISOString();
        }
        if (typeof v === &#x27;string&#x27; || typeof v === &#x27;number&#x27; || typeof v === &#x27;boolean&#x27; || v === null) {
            return v;
        }
        if (v &amp;&amp; v.$$date) {
            return v.$$date;
        }

        return v;
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
corruptItems = -1 // Last line of every data file is usually blank so not really corrupt
                ;

                for (i = 0; i &lt; data.length; i += 1) {
var doc;

try {
    doc = model.<span class="docApiCodeKeywordSpan">deserialize</span>(data[i]);
    if (doc._id) {
        if (doc.$$deleted === true) {
            delete dataById[doc._id];
        } else {
            dataById[doc._id] = doc;
        }
    } else if (doc.$$indexCreated &amp;&amp; doc.$$indexCreated.fieldName != undefined) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.getDotValue" id="element.Nedb.model.getDotValue">
            function <span class="docApiSignatureSpan">Nedb.model.</span>getDotValue
            <span class="docApiSignatureSpan">(obj, field)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function getDotValue(obj, field) {
    var fieldParts = typeof field === &#x27;string&#x27; ? field.split(&#x27;.&#x27;) : field,
        i, objs;

    if (!obj) {
        return undefined;
    } // field cannot be empty so that means we should return undefined so that nothing can match

    if (fieldParts.length === 0) {
        return obj;
    }

    if (fieldParts.length === 1) {
        return obj[fieldParts[0]];
    }

    if (Array.isArray(obj[fieldParts[0]])) {
        // If the next field is an integer, return only this item of the array
        i = parseInt(fieldParts[1], 10);
        if (typeof i === &#x27;number&#x27; &amp;&amp; !isNaN(i)) {
            return getDotValue(obj[fieldParts[0]][i], fieldParts.slice(2))
        }

        // Return the array of values
        objs = new Array();
        for (i = 0; i &lt; obj[fieldParts[0]].length; i += 1) {
            objs.push(getDotValue(obj[fieldParts[0]][i], fieldParts.slice(1)));
        }
        return objs;
    } else {
        return getDotValue(obj[fieldParts[0]], fieldParts.slice(1));
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
                candidates.forEach(function (candidate) {
var toPush;
if (action === 1) { // pick-type projection
    toPush = {
        $set: {}
    };
    keys.forEach(function (k) {
        toPush.$set[k] = model.<span class="docApiCodeKeywordSpan">getDotValue</span>(candidate, k);
        if (toPush.$set[k] === undefined) {
            delete toPush.$set[k];
        }
    });
    toPush = model.modify({}, toPush);
} else { // omit-type projection
    toPush = {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.isPrimitiveType" id="element.Nedb.model.isPrimitiveType">
            function <span class="docApiSignatureSpan">Nedb.model.</span>isPrimitiveType
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function isPrimitiveType(obj) {
    return (typeof obj === &#x27;boolean&#x27; ||
        typeof obj === &#x27;number&#x27; ||
        typeof obj === &#x27;string&#x27; ||
        obj === null ||
        local.isDate(obj) ||
        Array.isArray(obj));
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.match" id="element.Nedb.model.match">
            function <span class="docApiSignatureSpan">Nedb.model.</span>match
            <span class="docApiSignatureSpan">(obj, query)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function match(obj, query) {
    var queryKeys, queryKey, queryValue, i;

    // Primitive query against a primitive type
    // This is a bit of a hack since we construct an object with an arbitrary key only to dereference it later
    // But I don&#x27;t have time for a cleaner implementation now
    if (isPrimitiveType(obj) || isPrimitiveType(query)) {
        return matchQueryPart({
            needAKey: obj
        }, &#x27;needAKey&#x27;, query);
    }

    // Normal query
    queryKeys = Object.keys(query);
    for (i = 0; i &lt; queryKeys.length; i += 1) {
        queryKey = queryKeys[i];
        queryValue = query[queryKey];

        if (queryKey[0] === &#x27;$&#x27;) {
            if (!logicalOperators[queryKey]) {
                throw new Error(&quot;Unknown logical operator &quot; + queryKey);
            }
            if (!logicalOperators[queryKey](obj, queryValue)) {
                return false;
            }
        } else {
            if (!matchQueryPart(obj, queryKey, queryValue)) {
                return false;
            }
        }
    }

    return true;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
                this.db.getCandidates(this.query, function (error, candidates) {
if (error) {
    return callback(error);
}

try {
    for (i = 0; i &lt; candidates.length; i += 1) {
        if (model.<span class="docApiCodeKeywordSpan">match</span>(candidates[i], self.query)) {
            // If a sort is defined, wait for the results to be sorted before applying limit and skip
            if (!self._sort) {
                if (self._skip &amp;&amp; self._skip &gt; skipped) {
                    skipped += 1;
                } else {
                    res.push(candidates[i]);
                    added += 1;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.modify" id="element.Nedb.model.modify">
            function <span class="docApiSignatureSpan">Nedb.model.</span>modify
            <span class="docApiSignatureSpan">(obj, updateQuery)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function modify(obj, updateQuery) {
    var keys = Object.keys(updateQuery),
        firstChars = keys.map(function(item) {
            return item[0];
        }),
        dollarFirstChars = firstChars.filter(function(c) {
            return c === &#x27;$&#x27;;
        }),
        newDoc, modifiers;

    if (keys.indexOf(&#x27;_id&#x27;) !== -1 &amp;&amp; updateQuery._id !== obj._id) {
        throw new Error(&quot;You cannot change a document&#x27;s _id&quot;);
    }

    if (dollarFirstChars.length !== 0 &amp;&amp; dollarFirstChars.length !== firstChars.length) {
        throw new Error(&quot;You cannot mix modifiers and normal fields&quot;);
    }

    if (dollarFirstChars.length === 0) {
        // Simply replace the object with the update query contents
        newDoc = deepCopy(updateQuery);
        newDoc._id = obj._id;
    } else {
        // Apply modifiers
        modifiers = local.listUnique(keys);
        newDoc = deepCopy(obj);
        modifiers.forEach(function(m) {
            var keys;

            if (!modifierFunctions[m]) {
                throw new Error(&quot;Unknown modifier &quot; + m);
            }

            // Can&#x27;t rely on Object.keys throwing on non objects since ES6
            // Not 100% satisfying as non objects can be interpreted as objects but no false negatives so we can live with it
            if (typeof updateQuery[m] !== &#x27;object&#x27;) {
                throw new Error(&quot;Modifier &quot; + m + &quot;&#x27;s argument must be an object&quot;);
            }

            keys = Object.keys(updateQuery[m]);
            keys.forEach(function(k) {
                modifierFunctions[m](newDoc, k, updateQuery[m][k]);
            });
        });
    }

    // Check result is valid and return it
    checkObject(newDoc);

    if (obj._id !== newDoc._id) {
        throw new Error(&quot;You can&#x27;t change a document&#x27;s _id&quot;);
    }
    return newDoc;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    };
    keys.forEach(function (k) {
        toPush.$set[k] = model.getDotValue(candidate, k);
        if (toPush.$set[k] === undefined) {
            delete toPush.$set[k];
        }
    });
    toPush = model.<span class="docApiCodeKeywordSpan">modify</span>({}, toPush);
} else { // omit-type projection
    toPush = {
        $unset: {}
    };
    keys.forEach(function (k) {
        toPush.$unset[k] = true
    });
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.model.serialize" id="element.Nedb.model.serialize">
            function <span class="docApiSignatureSpan">Nedb.model.</span>serialize
            <span class="docApiSignatureSpan">(obj)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function serialize(obj) {
    var res;

    res = JSON.stringify(obj, function(k, v) {
        checkKey(k, v);

        if (v === undefined) {
            return undefined;
        }
        if (v === null) {
            return null;
        }

        // Hackish way of checking if object is Date (this way it works between execution contexts in node-webkit).
        // We can&#x27;t use value directly because for dates it is already string in this function (date.toJSON was already called),\
 so we use this
        if (typeof this[k].getTime === &#x27;function&#x27;) {
            return {
                $$date: this[k].getTime()
            };
        }

        return v;
    });

    return res;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
* this function will export the table as serialized-text
*/
   var data, self;
   self = this;
   data = &#x27;&#x27;;
   data += JSON.stringify(String(this.name)) + &#x27;\n&#x27;;
   self.getAllData().forEach(function (doc) {
       data += local.model.<span class="docApiCodeKeywordSpan">serialize</span>(doc) + &#x27;\n&#x27;;
   });
   Object.keys(self.indexes).forEach(function (fieldName) {
       if (fieldName === &#x27;_id&#x27;) {
           return;
       }
       data += local.model.serialize({ $$indexCreated: {
           fieldName: fieldName,
...</pre></li>
        </ul>
        
        
    </div>
    
    <div class="docApiSectionDiv">
    <h1><a href="#module.Nedb.persistence" id="module.Nedb.persistence">module Nedb.persistence</a></h1>
        
        
        <h2>
            <a href="#element.Nedb.persistence.persistence" id="element.Nedb.persistence.persistence">
            function <span class="docApiSignatureSpan">Nedb.</span>persistence
            <span class="docApiSignatureSpan">(options)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">function Persistence(options) {
    var i, j, randomString;

    this.db = options.db;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
    </div>
    
    <div class="docApiSectionDiv">
    <h1><a href="#module.Nedb.persistence.prototype" id="module.Nedb.persistence.prototype">module Nedb.persistence.prototype</a></h1>
        
        
        <h2>
            <a href="#element.Nedb.persistence.prototype.compactDatafile" id="element.Nedb.persistence.prototype.compactDatafile">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>compactDatafile
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">compactDatafile = function () {
    this.db.executor.push({
        this: this,
        fn: this.persistCachedDatabase,
        arguments: []
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.persistence.prototype.loadDatabase" id="element.Nedb.persistence.prototype.loadDatabase">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>loadDatabase
            <span class="docApiSignatureSpan">(cb)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">loadDatabase = function (cb) {
    var callback = cb,
        self = this;

    self.db.resetIndexes();

    var dir, modeNext, onNext;
    modeNext = 0;
    onNext = function (error) {
        modeNext = error
            ? Infinity
            : modeNext + 1;
        switch (modeNext) {
        case 1:
            local.storeGetItem(self.db.name, function(error, rawData) {
                try {
                    var treatedData = self.treatRawData(rawData || &#x27;&#x27;);
                } catch (e) {
                    return onNext(e);
                }

                // Recreate all indexes in the datafile
                Object.keys(treatedData.indexes).forEach(function(key) {
                    self.db.indexes[key] = new Index(treatedData.indexes[key]);
                });

                // Fill cached database (i.e. all indexes) with data
                try {
                    self.db.resetIndexes(treatedData.data);
                } catch (e) {
                    self.db.resetIndexes(); // Rollback any index which didn&#x27;t fail
                    return onNext(e);
                }

                self.db.persistence.persistCachedDatabase(onNext);
            });
            break;
        default:
            if (error) {
                return callback(error);
            }

<span class="docApiCodeCommentSpan">            /**
             * Queue all tasks in buffer (in the same order they came in)
             * Automatically sets executor as ready
             */
</span>            self.db.executor.ready = true;
            while (self.db.executor.buffer.length) {
                self.db.executor.queue.push(self.db.executor.buffer.shift());
            }

            return callback();
        }
    };
    onNext();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        break;
    case 2:
        if (self.isLoaded) {
            onNext();
            return;
        }
        self.isLoaded = true;
        self.<span class="docApiCodeKeywordSpan">loadDatabase</span>(onNext);
        break;
    default:
        onError(error, self);
    }
};
onNext(options.error);
return self;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.persistence.prototype.persistCachedDatabase" id="element.Nedb.persistence.prototype.persistCachedDatabase">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>persistCachedDatabase
            <span class="docApiSignatureSpan">(cb)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">persistCachedDatabase = function (cb) {
    var callback = cb,
        toPersist = &#x27;&#x27;,
        self = this;

    this.db.getAllData().forEach(function(doc) {
        toPersist += model.serialize(doc) + &#x27;\n&#x27;;
    });
    Object.keys(this.db.indexes).forEach(function(fieldName) {
        if (fieldName != &#x27;_id&#x27;) { // The special _id index is managed by datastore.js, the others need to be persisted
            toPersist += model.serialize({
                $$indexCreated: {
                    fieldName: fieldName,
                    unique: self.db.indexes[fieldName].unique,
                    sparse: self.db.indexes[fieldName].sparse
                }
            }) + &#x27;\n&#x27;;
        }
    });

    local.storeSetItem(this.db.name, toPersist, function(error) {
        if (error) {
            return callback(error);
        }
        return callback();
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        try {
            self.db.resetIndexes(treatedData.data);
        } catch (e) {
            self.db.resetIndexes(); // Rollback any index which didn&#x27;t fail
            return onNext(e);
        }

        self.db.persistence.<span class="docApiCodeKeywordSpan">persistCachedDatabase</span>(onNext);
    });
    break;
default:
    if (error) {
        return callback(error);
    }
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.persistence.prototype.persistNewState" id="element.Nedb.persistence.prototype.persistNewState">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>persistNewState
            <span class="docApiSignatureSpan">(newDocs, cb)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">persistNewState = function (newDocs, cb) {
<span class="docApiCodeCommentSpan">/**
 * Persist new state for the given newDocs (can be insertion, update or removal)
 * Use an append-only format
 * @param {Array} newDocs Can be empty if no doc was updated/removed
 * @param {Function} cb Optional, signature: error
 */
</span>    var self = this,
        toPersist = &#x27;&#x27;,
        callback = cb;

    newDocs.forEach(function(doc) {
        toPersist += model.serialize(doc) + &#x27;\n&#x27;;
    });

    if (toPersist.length === 0) {
        return callback();
    }

    local.storeGetItem(self.db.name, function (error, data) {
        local.storeSetItem(self.db.name, (data || &#x27;&#x27;) + toPersist, callback);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    this.indexes[options.fieldName].insert(this.getAllData());
} catch (e) {
    delete this.indexes[options.fieldName];
    return callback(e);
}

// We may want to force all options to be persisted including defaults, not just the ones passed the index creation function
this.persistence.<span class="docApiCodeKeywordSpan">persistNewState</span>([{
    $$indexCreated: options
}], function (error) {
    if (error) {
        return callback(error);
    }
    return callback();
});
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.persistence.prototype.treatRawData" id="element.Nedb.persistence.prototype.treatRawData">
            function <span class="docApiSignatureSpan">Nedb.persistence.prototype.</span>treatRawData
            <span class="docApiSignatureSpan">(rawData)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">treatRawData = function (rawData) {
    var data = rawData.split(&#x27;\n&#x27;),
        dataById = {},
        tdata = [],
        i, indexes = {},
        corruptItems = -1 // Last line of every data file is usually blank so not really corrupt
    ;

    for (i = 0; i &lt; data.length; i += 1) {
        var doc;

        try {
            doc = model.deserialize(data[i]);
            if (doc._id) {
                if (doc.$$deleted === true) {
                    delete dataById[doc._id];
                } else {
                    dataById[doc._id] = doc;
                }
            } else if (doc.$$indexCreated &amp;&amp; doc.$$indexCreated.fieldName != undefined) {
                indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;
            } else if (typeof doc.$$indexRemoved === &#x27;string&#x27;) {
                delete indexes[doc.$$indexRemoved];
            }
        } catch (errorCaught) {
            corruptItems += 1;
            // validate no error occurred
            local.assert(!corruptItems, errorCaught);
        }
    }

    Object.keys(dataById).forEach(function(k) {
        tdata.push(dataById[k]);
    });

    return {
        data: tdata,
        indexes: indexes
    };
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
                    modeNext = error
                        ? Infinity
                        : modeNext + 1;
                    switch (modeNext) {
                    case 1:
                        local.storeGetItem(self.db.name, function(error, rawData) {
try {
    var treatedData = self.<span class="docApiCodeKeywordSpan">treatRawData</span>(rawData || &#x27;&#x27;);
} catch (e) {
    return onNext(e);
}

// Recreate all indexes in the datafile
Object.keys(treatedData.indexes).forEach(function(key) {
    self.db.indexes[key] = new Index(treatedData.indexes[key]);
...</pre></li>
        </ul>
        
        
    </div>
    
    <div class="docApiSectionDiv">
    <h1><a href="#module.Nedb.prototype" id="module.Nedb.prototype">module Nedb.prototype</a></h1>
        
        
        <h2>
            <a href="#element.Nedb.prototype.addToIndexes" id="element.Nedb.prototype.addToIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>addToIndexes
            <span class="docApiSignatureSpan">(doc)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">addToIndexes = function (doc) {
    var i, failingIndex, error, keys = Object.keys(this.indexes);

    for (i = 0; i &lt; keys.length; i += 1) {
        try {
            this.indexes[keys[i]].insert(doc);
        } catch (e) {
            failingIndex = i;
            error = e;
            break;
        }
    }

    // If an error happened, we need to rollback the insert on all other indexes
    if (error) {
        for (i = 0; i &lt; failingIndex; i += 1) {
            this.indexes[keys[i]].remove(doc);
        }

        throw error;
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
 * If newDoc is an array of documents, this will insert all documents in the cache
 * @api private
 */
Datastore.prototype._insertInCache = function (preparedDoc) {
    if (Array.isArray(preparedDoc)) {
        this._insertMultipleDocsInCache(preparedDoc);
    } else {
        this.<span class="docApiCodeKeywordSpan">addToIndexes</span>(preparedDoc);
    }
};

/**
 * If one insertion fails (e.g. because of a unique constraint), roll back all previous
 * inserts and throws the error
 * @api private
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.count" id="element.Nedb.prototype.count">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>count
            <span class="docApiSignatureSpan">(query, callback)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">count = function (query, callback) {
    var cursor = new Cursor(this, query, function (error, docs, callback) {
        if (error) {
            return callback(error);
        }
        return callback(null, docs.length);
    });

    if (typeof callback === &#x27;function&#x27;) {
        cursor.exec(callback);
    } else {
        return cursor;
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
            return;
        }
        data.push(request.result.key);
        request.result.continue();
    };
    break;
case &#x27;length&#x27;:
    request = store.<span class="docApiCodeKeywordSpan">count</span>();
    break;
case &#x27;removeItem&#x27;:
    request = store.delete(options.key);
    break;
case &#x27;setItem&#x27;:
    request = store.put(options.value, options.key);
    break;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.createNewId" id="element.Nedb.prototype.createNewId">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>createNewId
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">createNewId = function () {
    var tentativeId = customUtils.uid(16);
    // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is \
extremely small, so this is O(1)
    if (this.indexes._id.getMatching(tentativeId).length &gt; 0) {
        tentativeId = this.createNewId();
    }
    return tentativeId;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
/**
 * Create a new _id that&#x27;s not already in use
 */
Datastore.prototype.createNewId = function () {
    var tentativeId = customUtils.uid(16);
    // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is \
extremely small, so this is O(1)
    if (this.indexes._id.getMatching(tentativeId).length &gt; 0) {
        tentativeId = this.<span class="docApiCodeKeywordSpan">createNewId</span>();
    }
    return tentativeId;
};

/**
 * Prepare a document (or array of documents) to be inserted in a database
 * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.ensureIndex" id="element.Nedb.prototype.ensureIndex">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>ensureIndex
            <span class="docApiSignatureSpan">(options, cb)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">ensureIndex = function (options, cb) {
<span class="docApiCodeCommentSpan">/**
 * Ensure an index is kept for this field. Same parameters as lib/indexes
 * For now this function is synchronous, we need to test how much time it takes
 * We use an async API for consistency with the rest of the code
 * @param {String} options.fieldName
 * @param {Boolean} options.unique
 * @param {Boolean} options.sparse
 * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not \
arrays of Date)
 * @param {Function} cb Optional callback, signature: error
 */
</span>    var error, callback = cb;
    if (!options.fieldName) {
        error = new Error(&quot;Cannot create an index without a fieldName&quot;);
        error.missingFieldName = true;
        return callback(error);
    }
    if (this.indexes[options.fieldName]) {
        return callback();
    }

    this.indexes[options.fieldName] = new Index(options);
    if (options.expireAfterSeconds !== undefined) {
        this.ttlIndexes[options.fieldName] = options.expireAfterSeconds;
    } // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB&#x27;s API here

    try {
        this.indexes[options.fieldName].insert(this.getAllData());
    } catch (e) {
        delete this.indexes[options.fieldName];
        return callback(e);
    }

    // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function
    this.persistence.persistNewState([{
        $$indexCreated: options
    }], function (error) {
        if (error) {
            return callback(error);
        }
        return callback();
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
local.testCase_dbExport_default = function (options, onError) {
/*
 * this function will test dbExport&#x27;s default handling-behavior
 */
    options = {};
    options.name = &#x27;testCase_dbExport_default&#x27;;
    options.table = local.dbTableCreate(options);
    options.table.<span class="docApiCodeKeywordSpan">ensureIndex</span>({
        fieldName: &#x27;id&#x27;,
        unique: true
    }, local.utility2.onErrorDefault);
    options.data = local.dbExport();
    // validate data
    local.utility2.assert(options.data.indexOf(&#x27;&quot;testCase_dbExport_default&quot;\n&#x27; +
        &#x27;{&quot;$$indexCreated&quot;:{&quot;fieldName&quot;:&quot;createdAt&quot;,&quot;unique&quot;:false,&quot;sparse&quo\
t;:false}}\n&#x27; +
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.export" id="element.Nedb.prototype.export">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>export
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">export = function () {
<span class="docApiCodeCommentSpan">/*
 * this function will export the table as serialized-text
 */
</span>    var data, self;
    self = this;
    data = &#x27;&#x27;;
    data += JSON.stringify(String(this.name)) + &#x27;\n&#x27;;
    self.getAllData().forEach(function (doc) {
        data += local.model.serialize(doc) + &#x27;\n&#x27;;
    });
    Object.keys(self.indexes).forEach(function (fieldName) {
        if (fieldName === &#x27;_id&#x27;) {
            return;
        }
        data += local.model.serialize({ $$indexCreated: {
            fieldName: fieldName,
            unique: self.indexes[fieldName].unique,
            sparse: self.indexes[fieldName].sparse
        } }) + &#x27;\n&#x27;;
    });
    return data.slice(0, -1);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
            target=&quot;_blank&quot;\n\
        &gt;eval&lt;/a&gt;\n\
    &lt;/label&gt;\n\
&lt;textarea class=&quot;onkeyup&quot; id=&quot;inputTextarea1&quot;&gt;\n\
window.table1 = window.Nedb.dbTableCreate({ name: &quot;table1&quot; });\n\
table1.insert({ field1: &quot;hello&quot;, field2: &quot;world&quot;}, function () {\n\
    console.log();\n\
    console.log(table1.<span class="docApiCodeKeywordSpan">export</span>());\n\
});\n\
\n\
window.table2 = window.Nedb.dbTableCreate({ name: &quot;table2&quot; });\n\
table2.insert({ field1: &quot;hello&quot;, field2: &quot;world&quot;}, function () {\n\
    console.log();\n\
    console.log(table2.export());\n\
});\n\
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.find" id="element.Nedb.prototype.find">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>find
            <span class="docApiSignatureSpan">(query, projection, callback)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">find = function (query, projection, callback) {
    switch (arguments.length) {
        case 1:
            projection = {};
            // callback is undefined, will return a cursor
            break;
        case 2:
            if (typeof projection === &#x27;function&#x27;) {
                callback = projection;
                projection = {};
            } // If not assume projection is an object and callback undefined
            break;
    }

    var cursor = new Cursor(this, query, function (error, docs, callback) {
        var res = [],
            i;

        if (error) {
            return callback(error);
        }

        for (i = 0; i &lt; docs.length; i += 1) {
            res.push(model.deepCopy(docs[i]));
        }
        return callback(null, res);
    });

    cursor.projection(projection);
    if (typeof callback === &#x27;function&#x27;) {
        cursor.exec(callback);
    } else {
        return cursor;
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.findOne" id="element.Nedb.prototype.findOne">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>findOne
            <span class="docApiSignatureSpan">(query, projection, callback)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">findOne = function (query, projection, callback) {
    switch (arguments.length) {
        case 1:
            projection = {};
            // callback is undefined, will return a cursor
            break;
        case 2:
            if (typeof projection === &#x27;function&#x27;) {
                callback = projection;
                projection = {};
            } // If not assume projection is an object and callback undefined
            break;
    }

    var cursor = new Cursor(this, query, function (error, docs, callback) {
        if (error) {
            return callback(error);
        }
        if (docs.length === 1) {
            return callback(null, model.deepCopy(docs[0]));
        } else {
            return callback(null, null);
        }
    });

    cursor.projection(projection).limit(1);
    if (typeof callback === &#x27;function&#x27;) {
        cursor.exec(callback);
    } else {
        return cursor;
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
options = {};
local.utility2.onNext(options, function (error, data) {
    switch (options.modeNext) {
    case 1:
        options = local.crudOptionsSetDefault(options, {
            id: &#x27;00_test_dbTableFindOneById&#x27;
        });
        options.table.<span class="docApiCodeKeywordSpan">findOne</span>({ id: options.id }, options.onNext);
        break;
    case 2:
        // validate data
        local.utility2.assertJsonEqual(data.id, options.id);
        options.onNext();
        break;
    default:
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.getAllData" id="element.Nedb.prototype.getAllData">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>getAllData
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">getAllData = function () {
    return this.indexes._id.getAll();
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        /*
* this function will export the table as serialized-text
*/
   var data, self;
   self = this;
   data = &#x27;&#x27;;
   data += JSON.stringify(String(this.name)) + &#x27;\n&#x27;;
   self.<span class="docApiCodeKeywordSpan">getAllData</span>().forEach(function (doc) {
       data += local.model.serialize(doc) + &#x27;\n&#x27;;
   });
   Object.keys(self.indexes).forEach(function (fieldName) {
       if (fieldName === &#x27;_id&#x27;) {
           return;
       }
       data += local.model.serialize({ $$indexCreated: {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.getCandidates" id="element.Nedb.prototype.getCandidates">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>getCandidates
            <span class="docApiSignatureSpan">(query, dontExpireStaleDocs, callback)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">getCandidates = function (query, dontExpireStaleDocs, callback) {
<span class="docApiCodeCommentSpan">/**
 * Return the list of candidates for a given query
 * Crude implementation for now, we return the candidates given by the first usable index if any
 * We try the following query types, in this order: basic match, $in match, comparison match
 * One way to make it better would be to enable the use of multiple indexes if the first usable index
 * returns too much data. I may do it in the future.
 *
 * Returned candidates will be scanned to find and remove all expired documents
 *
 * @param {Query} query
 * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don&#x27;t remove stale docs. Useful for the remove func\
tion which shouldn&#x27;t be impacted by expirations
 * @param {Function} callback Signature error, candidates
 */
</span>    var self = this,
        usableQueryKeys;

    if (typeof dontExpireStaleDocs === &#x27;function&#x27;) {
        callback = dontExpireStaleDocs;
        dontExpireStaleDocs = false;
    }


    var modeNext, onNext;
    modeNext = 0;
    onNext = function (error, docs) {
        modeNext = error
            ? Infinity
            : modeNext + 1;
        switch (modeNext) {
        // STEP 1: get candidates list by checking indexes from most to least frequent usecase
        case 1:
            // For a basic match
            usableQueryKeys = [];
            Object.keys(query).forEach(function (k) {
                if (typeof query[k] === &#x27;string&#x27; || typeof query[k] === &#x27;number&#x27; || typeof query[k] === &#x27;boolean&#x27; || local.isDat\
e(query[k]) || query[k] === null) {
                    usableQueryKeys.push(k);
                }
            });
            usableQueryKeys = usableQueryKeys.filter(function (element) {
                return self.indexes.hasOwnProperty(element);
            });
            if (usableQueryKeys.length &gt; 0) {
                return onNext(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));
            }

            // For a $in match
            usableQueryKeys = [];
            Object.keys(query).forEach(function (k) {
                if (query[k] &amp;&amp; query[k].hasOwnProperty(&#x27;$in&#x27;)) {
                    usableQueryKeys.push(k);
                }
            });
            usableQueryKeys = usableQueryKeys.filter(function (element) {
                return self.indexes.hasOwnProperty(element);
            });
            if (usableQueryKeys.length &gt; 0) {
                return onNext(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));
            }

            // For a comparison match
            usableQueryKeys = [];
            Object.keys(query).forEach(function (k) {
                if (query[k] &amp;&amp; (query[k].hasOwnProperty(&#x27;$lt&#x27;) || query[k].hasOwnProperty(&#x27;$lte&#x27;) || query[k].hasOwnProperty(&#x27;$\
gt&#x27;) || query[k].hasOwnProperty(&#x27;$gte&#x27;))) {
                    usableQueryKeys.push(k);
                }
            });
            usableQueryKeys = usableQueryKeys.filter(function (element) {
                return self.indexes.hasOwnProperty(element);
            });
            if (usableQueryKeys.length &gt; 0) {
                return onNext(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));
            }

            // By default, return all the DB data
            return onNext(null, self.getAllData());
        // STEP 2: remove all expired documents
        default:
            if (dontExpireStaleDocs) {
                return callback(null, docs);
            }

            var expiredDocsIds = [],
                validDocs = [],
                ttlIndexesFieldNames = Object.keys(self.ttlIndexes);

            docs.forEach(function (doc) {
                var valid = true;
                ttlIndexesFieldNames.forEach(function (i) {
                    if (doc[i] !== undefined &amp;&amp; local.isDate(doc[i]) &amp;&amp; Date.now() &gt; doc[i].getTime() + self.ttlIndexes[i] * 100\
0) {
                        valid = false;
                    }
                });
                if (valid) {
                    validDocs.push(doc); ...</pre></li>
        <li>example usage<pre class="docApiCodePre">...
if (self.execFn) {
    return self.execFn(error, res, _callback);
} else {
    return _callback(error, res);
}
                }

                this.db.<span class="docApiCodeKeywordSpan">getCandidates</span>(this.query, function (error, candidates) {
if (error) {
    return callback(error);
}

try {
    for (i = 0; i &lt; candidates.length; i += 1) {
        if (model.match(candidates[i], self.query)) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.insert" id="element.Nedb.prototype.insert">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>insert
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">insert = function () {
    this.executor.push({
        this: this,
        fn: this._insert,
        arguments: arguments
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    &lt;a\n\
        href=&quot;https://kaizhu256.github.io/node-nedb-lite/build/doc.api.html&quot;\n\
        target=&quot;_blank&quot;\n\
    &gt;eval&lt;/a&gt;\n\
&lt;/label&gt;\n\
&lt;textarea class=&quot;onkeyup&quot; id=&quot;inputTextarea1&quot;&gt;\n\
window.table1 = window.Nedb.dbTableCreate({ name: &quot;table1&quot; });\n\
table1.<span class="docApiCodeKeywordSpan">insert</span>({ field1: &quot;hello&quot;, field2: &quot;world&quot;}, function () {\\
n\
console.log();\n\
console.log(table1.export());\n\
});\n\
\n\
window.table2 = window.Nedb.dbTableCreate({ name: &quot;table2&quot; });\n\
table2.insert({ field1: &quot;hello&quot;, field2: &quot;world&quot;}, function () {\n\
console.log();\n\
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.load" id="element.Nedb.prototype.load">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>load
            <span class="docApiSignatureSpan">(options, onError)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">load = function (options, onError) {
    var data, modeNext, onNext, self;
    self = this;
    modeNext = 0;
    onNext = function (error) {
        modeNext = error
            ? Infinity
            : modeNext + 1;
        switch (modeNext) {
        case 1:
            onError = onError || function (error) {
                // validate no error occurred
                local.assert(!error, error);
            };
            data = (options.persistenceData || &#x27;&#x27;).trim();
            if (options.reset) {
                data = &#x27;undefined&#x27;;
            }
            if (!data) {
                onNext();
                return;
            }
            self.isLoaded = null;
            data += &#x27;\n&#x27;;
            data = data.slice(data.indexOf(&#x27;\n&#x27;) + 1);
            local.storeSetItem(self.name, data, onNext);
            break;
        case 2:
            if (self.isLoaded) {
                onNext();
                return;
            }
            self.isLoaded = true;
            self.loadDatabase(onNext);
            break;
        default:
            onError(error, self);
        }
    };
    onNext(options.error);
    return self;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    // binary is always well-balanced
    this.indexes = {
        _id: new local.Index({ fieldName: &#x27;_id&#x27;, unique: true }),
        createdAt: new local.Index({ fieldName: &#x27;createdAt&#x27; }),
        updatedAt: new local.Index({ fieldName: &#x27;updatedAt&#x27; })
    };
    this.ttlIndexes = {};
    this.<span class="docApiCodeKeywordSpan">load</span>(options, onError);
};
local.Nedb = local.local = local;
// init modeJs
local.modeJs = (function () {
    try {
        return typeof navigator.userAgent === &#x27;string&#x27; &amp;&amp;
            typeof document.querySelector(&#x27;body&#x27;) === &#x27;object&#x27; &amp;&amp;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.loadDatabase" id="element.Nedb.prototype.loadDatabase">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>loadDatabase
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">loadDatabase = function () {
    this.executor.push({
        this: this.persistence,
        fn: this.persistence.loadDatabase,
        arguments: arguments
    }, true);
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
        break;
    case 2:
        if (self.isLoaded) {
            onNext();
            return;
        }
        self.isLoaded = true;
        self.<span class="docApiCodeKeywordSpan">loadDatabase</span>(onNext);
        break;
    default:
        onError(error, self);
    }
};
onNext(options.error);
return self;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.prepareDocumentForInsertion" id="element.Nedb.prototype.prepareDocumentForInsertion">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>prepareDocumentForInsertion
            <span class="docApiSignatureSpan">(newDoc)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">prepareDocumentForInsertion = function (newDoc) {
    var preparedDoc, self = this;

    if (Array.isArray(newDoc)) {
        preparedDoc = [];
        newDoc.forEach(function (doc) {
            preparedDoc.push(self.prepareDocumentForInsertion(doc));
        });
    } else {
        preparedDoc = model.deepCopy(newDoc);
        if (preparedDoc._id === undefined) {
            preparedDoc._id = this.createNewId();
        }
        var now = new Date().toISOString();
        if (preparedDoc.createdAt === undefined) {
            preparedDoc.createdAt = now;
        }
        if (preparedDoc.updatedAt === undefined) {
            preparedDoc.updatedAt = now;
        }
        model.checkObject(preparedDoc);
    }

    return preparedDoc;
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
             * @api private Use Datastore.insert which has the same signature
             */
            Datastore.prototype._insert = function (newDoc, cb) {
var callback = cb,
    preparedDoc;

try {
    preparedDoc = this.<span class="docApiCodeKeywordSpan">prepareDocumentForInsertion</span>(newDoc)
    this._insertInCache(preparedDoc);
} catch (e) {
    return callback(e);
}

this.persistence.persistNewState(Array.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (error) {
    if (error) {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.remove" id="element.Nedb.prototype.remove">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>remove
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">remove = function () {
    this.executor.push({
        this: this,
        fn: this._remove,
        arguments: arguments
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
case 1:
    options = local.crudOptionsSetDefault(options, {
        id: &#x27;00_test_dbTableRemoveOneById&#x27;
    });
    local.testCase_dbTableFindOneById_default(options, options.onNext);
    break;
case 2:
    options.table.<span class="docApiCodeKeywordSpan">remove</span>({ id: options.id }, options.onNext);
    break;
case 3:
    options.table.findOne({ id: options.id }, options.onNext);
    break;
case 4:
    // validate data was removed
    local.utility2.assertJsonEqual(data, null);
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.removeFromIndexes" id="element.Nedb.prototype.removeFromIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>removeFromIndexes
            <span class="docApiSignatureSpan">(doc)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">removeFromIndexes = function (doc) {
    var self = this;

    Object.keys(this.indexes).forEach(function (i) {
        self.indexes[i].remove(doc);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
            failingI = i;
            break;
        }
    }

    if (error) {
        for (i = 0; i &lt; failingI; i += 1) {
            this.<span class="docApiCodeKeywordSpan">removeFromIndexes</span>(preparedDocs[i]);
        }

        throw error;
    }
};

Datastore.prototype.insert = function () {
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.removeIndex" id="element.Nedb.prototype.removeIndex">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>removeIndex
            <span class="docApiSignatureSpan">(fieldName, cb)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">removeIndex = function (fieldName, cb) {
    var callback = cb;

    delete this.indexes[fieldName];

    this.persistence.persistNewState([{
        $$indexRemoved: fieldName
    }], function (error) {
        if (error) {
            return callback(error);
        }
        return callback();
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">n/a</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.resetIndexes" id="element.Nedb.prototype.resetIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>resetIndexes
            <span class="docApiSignatureSpan">(newData)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">resetIndexes = function (newData) {
    var self = this;

    Object.keys(this.indexes).forEach(function (i) {
        self.indexes[i].reset(newData);
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
             * This operation is very quick at startup for a big collection (60ms for ~10k docs)
             * @param {Function} cb Optional callback, signature: error
             */
            Persistence.prototype.loadDatabase = function(cb) {
var callback = cb,
    self = this;

self.db.<span class="docApiCodeKeywordSpan">resetIndexes</span>();

var dir, modeNext, onNext;
modeNext = 0;
onNext = function (error) {
    modeNext = error
        ? Infinity
        : modeNext + 1;
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.update" id="element.Nedb.prototype.update">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>update
            <span class="docApiSignatureSpan">()</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">update = function () {
    this.executor.push({
        this: this,
        fn: this._update,
        arguments: arguments
    });
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
             * If one update violates a constraint, all changes are rolled back
             */
            Datastore.prototype.updateIndexes = function (oldDoc, newDoc) {
var i, failingIndex, error, keys = Object.keys(this.indexes);

for (i = 0; i &lt; keys.length; i += 1) {
    try {
        this.indexes[keys[i]].<span class="docApiCodeKeywordSpan">update</span>(oldDoc, newDoc);
    } catch (e) {
        failingIndex = i;
        error = e;
        break;
    }
}
...</pre></li>
        </ul>
        
        
        
        <h2>
            <a href="#element.Nedb.prototype.updateIndexes" id="element.Nedb.prototype.updateIndexes">
            function <span class="docApiSignatureSpan">Nedb.prototype.</span>updateIndexes
            <span class="docApiSignatureSpan">(oldDoc, newDoc)</span>
            </a>
        </h2>
        <ul>
        <li>description and source code<pre class="docApiCodePre">updateIndexes = function (oldDoc, newDoc) {
    var i, failingIndex, error, keys = Object.keys(this.indexes);

    for (i = 0; i &lt; keys.length; i += 1) {
        try {
            this.indexes[keys[i]].update(oldDoc, newDoc);
        } catch (e) {
            failingIndex = i;
            error = e;
            break;
        }
    }

    // If an error happened, we need to rollback the update on all other indexes
    if (error) {
        for (i = 0; i &lt; failingIndex; i += 1) {
            this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);
        }

        throw error;
    }
}</pre></li>
        <li>example usage<pre class="docApiCodePre">...
    }
} catch (error) {
    return callback(error);
}

// Change the docs in memory
try {
    self.<span class="docApiCodeKeywordSpan">updateIndexes</span>(modifications);
} catch (error) {
    return callback(error);
}

// Update the datafile
var updatedDocs = modifications.map(function (element) {
    return element.newDoc;
...</pre></li>
        </ul>
        
        
    </div>
    
</div>
